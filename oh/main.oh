# see `usage`.
main_(arguments{str_};): pipeline_ result_
     options; _(arguments)
          ok. {ok}
          er.
          {    print_(er: usage)
               print_(er)
               return: 1
          }
     result;
     what options path!
          directory_path:
               execute; _ mains_([])
               recurse: recurse_
               (    directory_path
                    options action
                    options mode o_()
                    execute
               )
               result |= recurse result
               if recurse oh_file_count == 0
                    print_(er: "did not find any .oh files in $(directory_path) or subdirectories")
                    result |= no_oh_files
               elif options action has_run_()
                    if execute mains count_() == 0
                         print_(er: "did not find any main functions in $(directory_path)")
                         result |= _ no_main_function
                    elif execute mains count_() > 1
                         print_(er: "found multiple main functions in $(directory_path), not running any!")
                         result |= _ too_many_main_functions
                    else
                         result |= do_
                         (    execute mains remove_()
                              action_ run
                              options mode o_()
                         )
          regular_file_path.
               result |= do_
               (    options action
                    options mode
                    regular_file_path
                    execute_ this
               )
     result

recurse_(directory_path:, action., mode., execute;): [result:, oh_file_count:]
     result;
     oh_file_count;

     directory_path each regular_file_path.
          if regular_file_path ends_with_(".oh")
               result |= do_
               (    options action o_()
                    options mode o_()
                    regular_file_path
                    execute
               )
               oh_file_count += 1

     directory_path each SUB_directory_path:
          # recurse but do not execute these:
          recurse: recurse_
          (    SUB_directory_path
               action o_()
               mode o_()
               execute_ none
          )
          result |= recurse result
          oh_file_count += recurse oh_file_count

     [result, oh_file_count]

do_(regular_file_path:, action., mode., execute;): result_
     # TODO: remove this when formatting is supported
     if action has_format_()
          print_(er: "formatting currently not supported")
          action &= <>_ format

     pipeline; _(regular_file_path)
     if action has_format_()
          format_(pipeline)
     else
          parse_(pipeline)

     if action has_compile_() || action has_run_()
          compile_(pipeline)

     # TODO: don't run if `execute` is `mains`, just add it to the list if it has a main function
     if action has_run_()
          pass # TODO
     pipeline result

parse_(pipeline;): null_
     read_(pipeline)
     if pipeline result cannot_continue_()
          return
     tokens: _(lines) when er.
          pipeline result |= _ invalid_syntax
          print_(er)
          # `tokens_(lines)` updates `lines` to have the error, try
          # writing to the file to guide what needs to be fixed.
          write_(pipeline)
          return
     pipeline lines = lines
     pipeline tokens = tokens

format_(pipeline;): null_
     parse_(pipeline)
     if pipeline cannot_continue_()
          return
     # TODO: actually update `pipeline lines` based on `pipeline tokens`.

     # now write the file with the formatted content
     write_(pipeline)
     # not being able to write the file doesn't stop us from continuing
     # the pipeline, but it does stop us from being able to use the
     # formatted file lines as the source of truth; reparse.
     if pipeline result & _ could_not_write_file
          print_(er: "could not write file $(pipeline regular_file_path) when formatting, reparsing to have valid lines")
          parse_(pipeline)

read_(pipeline;): null_
     regular_file; pipeline regular_file_path open_(_ read_only) when er.
          print_(er: "could not open file $(pipeline regular_file_path) for reading: $(er)")
          pipeline result |= _ could_not_read_file
          return
     pipeline lines = regular_file read_() when er.
          print_(er: "could not open file $(pipeline regular_file_path) for reading: $(er)")
          pipeline result |= _ could_not_read_file
          []

write_(pipeline;): null_
     regular_file; pipeline regular_file_path open_(_ truncate_write)
     regular_file write_(pipeline lines) when er.
          print_(er: "could not write file $(pipeline regular_file_path): $(er)")
          pipeline result |= _ could_not_write_file

result_: arch_ signed_
{    could_not_read_file: m_ = -1
     no_errors: m_ = 0
     could_not_write_file: m_ = 1
     invalid_syntax: m_ = 2
     no_main_function: m_ = 32
     too_many_main_functions: m_ = 64
     no_oh_files: m_ = 128
}

pipeline_: [regular_file_path:, lines;, tokens;, result;, has_main; bool_]
{    ::cannot_continue_(): bool_
          !m can_continue_()

     ::can_continue_(): bool_
          what m result
               _ could_not_read_file
               _ invalid_syntax
                    false
               else
                    true
}

execute_: one_of_
{    this:
     # do not execute this file
     none:
     # contains a list of paths that could be executed
     # since they have a main in them.
     mains: array_{regular_file_path_}
}
lines_: array_{str_}

oh_file_count_: arch_ count_(0)
[tokens_]: \/tokens
# TODO: `[_, ...]: \/options` if we like that syntax to get `options_`.
[options_, usage, action_, mode_]: \/options
