# see `usage`.
main_(arguments{str_};): pipeline_ result_
     options; _(arguments)
          ok. {ok}
          er.
          {    print_(er: usage)
               print_(er)
               return: 1
          }
     result;
     what options path!
          directory_path:
               execute; _ mains_([])
               recurse: recurse_
               (    directory_path
                    options action
                    options mode o_()
                    execute
               )
               result |= recurse result
               if recurse oh_file_count == 0
                    print_
                    (    er: "did not find any .oh files in $(directory_path)"
                              &    "or subdirectories"
                    )
                    result |= no_oh_files
               elif options action has_run_()
                    result |= run_
                    (    execute mains!
                         directory_path
                         options mode o_()
                    )
          regular_file_path.
               result |= do_
               (    regular_file_path
                    options action
                    options mode
                    execute_ this
               )
     result

# TODO: do we want to define a `recurse_` type based on the default return value of `recurse_(...)`?
recurse_(directory_path:, action., mode., execute;): [result:, oh_file_count:]
     result;
     oh_file_count;

     directory_path each regular_file_path.
          if regular_file_path ends_with_(".oh")
               result |= do_
               (    options action o_()
                    options mode o_()
                    regular_file_path
                    execute
               )
               oh_file_count += 1

     directory_path each SUB_directory_path:
          # recurse but do not execute these:
          recurse: recurse_
          (    SUB_directory_path
               action o_()
               mode o_()
               execute_ none
          )
          result |= recurse result
          oh_file_count += recurse oh_file_count

     [result, oh_file_count]

do_(regular_file_path., action., mode., execute;): result_
     # TODO: remove this when formatting is supported
     if action has_format_()
          print_(er: "formatting currently not supported")
          action &= <>_ format

     pipeline; _(regular_file_path)

     # format/parse
     if action has_format_()
          format_(pipeline)
     else
          parse_(pipeline)

     # compile (as needed, also when running)
     if action & (_ compile | _ run)
          compile_(pipeline, mode o_())

     # run
     if action has_run_()
          what execute
               _ none
                    pass
               _ mains;
                    if pipeline has_main
                         mains append_(regular_file_path)
               _ this
                    run_(pipeline regular_file_path, mode o_())

     pipeline result

run_(directory_path:, mains. array{regular_file_path_}, mode.): result_
     if mains count_() == 1
          run_
          (    mains remove_()
               mode
          )
     elif mains count_() == 0
          print_(er: "did not find any main functions in $(directory_path)")
          _ no_main_function
     else
          print_
          (    er: "found multiple main functions in $(directory_path),"
                    &    "not running any!"
          )
          _ too_many_main_functions

# TODO: pass in arguments
run_(regular_file_path:, mode.): result_
     executable_file_path: mode file_path_(regular_file_path)
     # TODO

parse_(pipeline;): null_
     read_(pipeline)
     if pipeline cannot_continue_()
          return
     pipeline tokens = _(pipeline lines) when er.
          pipeline result |= _ invalid_syntax
          print_(er)
          # `tokens_(lines)` updates `lines` to have error lines,
          # try writing to the file to guide what needs to be fixed.
          pipeline result |= write_(pipeline)
          []

format_(pipeline;): null_
     parse_(pipeline)
     if pipeline cannot_continue_()
          return
     # TODO: actually update `pipeline lines` based on `pipeline tokens`.

     # now write the file with the formatted content
     write_(pipeline)

     # not being able to write the file doesn't stop us from continuing
     # the pipeline, but it does stop us from being able to use the
     # formatted file lines as the source of truth; reparse.
     if pipeline result & _ could_not_write_file
          print_(er: "could not write file $(pipeline regular_file_path) when formatting, reparsing to have valid lines")
          parse_(pipeline)

read_(pipeline;): null_
     regular_file; pipeline regular_file_path open_(_ read_only) when er.
          print_(er: "could not open file $(pipeline regular_file_path) for reading: $(er)")
          pipeline result |= _ could_not_read_file
          return
     pipeline lines = regular_file read_() when er.
          print_(er: "could not open file $(pipeline regular_file_path) for reading: $(er)")
          pipeline result |= _ could_not_read_file
          []

write_(pipeline;): null_
     regular_file; pipeline regular_file_path open_(_ truncate_write)
     regular_file write_(pipeline lines) when er.
          print_(er: "could not write file $(pipeline regular_file_path): $(er)")
          pipeline result |= _ could_not_write_file

result_: arch_ signed_
{    could_not_read_file: m_ = -1
     no_errors: m_ = 0
     could_not_write_file: m_ = 1
     invalid_syntax: m_ = 2
     no_main_function: m_ = 32
     too_many_main_functions: m_ = 64
     no_oh_files: m_ = 128
}

pipeline_:
[    regular_file_path:
     lines;
     tokens;
     result;
     has_main; bool_
]
{    ::cannot_continue_(): bool_
          !m can_continue_()

     ::can_continue_(): bool_
          what m result
               _ could_not_read_file
               _ invalid_syntax
                    false
               else
                    true
}

execute_: one_of_
{    # do not execute this file
     none:
     # execute the main function in this file, after
     # executing any other code in the global/root scope.
     # TODO: provide a list of arguments
     this:
     # contains a list of paths that could be executed
     # since they have a main in them.
     mains: array_{regular_file_path_}
}

lines_: array_{str_}

oh_file_count_: arch_ count_(0)
[tokens_]: \/tokens
# TODO: `[_, ...]: \/options` if we like that syntax to get `options_`.
[options_, usage, action_, mode_]: \/options
