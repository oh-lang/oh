usage:
          +|usage:
          +|   oh   # formats/compiles everything in the current directory and subdirectories.
          +|        # if there is one `main_` function in the *current directory*, runs it,
          +|        #    otherwise prints an error.
          +|        # if there are unit tests in any affected files, runs them.
          +|        # it is equivalent to `oh .`
          +|   oh path/to/file.oh  # formats and compiles path/to/file.oh;
          +|                       # runs any code in the global scope of the file.
          +|                       # runs unit tests, if present in the file.
          +|   oh path/to/dir/     # formats and compiles path/to/dir/ and subdirectories.
          +|                       # if there is one `main_` function in path/to/dir/,
          +|                       #    runs it, otherwise prints an error.
          +|                       # if there are unit tests in any affected files, runs them.
          +|   # |=options=[
          +|   # |=actions=(
          +|   # you can combine --format, --compile, --test, and --run to do only those;
          +|   # the default acts in this order: format, compile, run, and test
          +|   oh --compile [path] # compile path ?? everything
          +|   oh --format [path]  # format path ?? everything
          +|   oh --run [path]     # runs code in path ?? looks for a `main_` function
          +|                       #    according to path rules (see dir/file.oh logic)
          +|   oh --test [path]    # runs tests in path ?? everything
          +|   # )=actions=|
          +|   # |==modes==(
          +|   # the default mode is --debug.
          +|   oh --release [path] # handles path ?? everything in release mode
          +|   oh --debug [path]   # handles path ?? everything in debug mode
          +|   # )==modes==|
          +|   # ]=options=|

options_:
[    mode;
     action;
     path;
]
{    m_(arguments{str_};): hm_{ok_: m_, er_: str_}
          mode?;
          action?;
          path?;
          arguments each str.
               hm: what str
                    # abc{
                    "--compile" {add_action_(action, _ compile)}
                    "--debug" {set_mode_(mode, _ debug)}
                    "--format" {add_action_(action, _ format)}
                    "--release" {set_mode_(mode, _ release)}
                    "--test" {add_action_(action, _ test)}
                    # }xyz
                    # TODO: if `arg` starts with `--` or `-` then we should
                    #         probably give a different error.
                    arg. {add_path_(path, arg)}
               hm assert_()
          ok_
          ([   mode ?? _ debug
               action ?? _ format | _ compile | _ run | _ test
               path ?? os cwd_()
          ])

     @private
     set_mode_(mode?;, SET_mode.): hm_{ok_: null_, er_: str_}
          if mode != null
               er_("already have set mode $(mode), can't update to $(SET_mode)")
          else
               mode = SET_mode
               ok_()

     @private
     add_action_(action?;, ADD_action.): hm_{ok_: null_, er_: str_}
          if action & ADD_action
               er_("already have set action with $(ADD_action), currently $(action)")
          else
               action |= ADD_action
               ok_()

     @private
     add_path_(path?; path_, str.): hm_{ok_: null_, er_: str_}
          valid_file_path. file_path_(str) resolve_() when FILE_er.
               return. er_(FILE_er)
          if !valid_file_path exists_()
               return. er_("file $(valid_file_path) does not exist")
          if m path != null
               # currently unsupported.
               # it's a bit confusing how we'd handle `--run` specifically;
               # if there are multiple files do we run them all sequentially,
               # then run their tests?  if the path is a directory, we look for
               # a `main_` file, but if you also pass in a regular file path,
               # do we look for a `main_` file and also run the regular file?
               er_("we currently do not support passing in multiple paths")
          else
               m path = valid_file_path
               ok_()

     mode_: mode_
     action_: action_
     # it's a bit stronger than just `valid_file_path_` since we also verify
     # if this file already exists, at least at the time of resolution.
     path_: valid_file_path_
}

mode_: one_of_{release:, debug:}
action_: any_of_{format:, compile:, run:, test:}
