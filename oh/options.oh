usage:
          +|usage:
          +|   oh   # formats/compiles everything in the current directory and subdirectories.
          +|        # if there is one `main_` function in the *current directory*, runs it,
          +|        #    otherwise prints an error.
          +|        # if there are unit tests in any affected files, runs them.
          +|        # it is equivalent to `oh .`
          +|   oh path/to/file.oh  # formats and compiles path/to/file.oh;
          +|                       # runs any code in the global scope of the file.
          +|                       # runs unit tests, if present in the file.
          +|   oh path/to/dir/     # formats and compiles path/to/dir/ and subdirectories.
          +|                       # if there is one `main_` function in path/to/dir/,
          +|                       #    runs it, otherwise prints an error.
          +|                       # if there are unit tests in any affected files, runs them.
          +|   # |=options=[
          +|   # |=actions=(
          +|   # you can combine --format, --compile, --test, and --run to do only those;
          +|   # the default acts in this order: format, compile, run, and test
          +|   oh --compile [path] # compile path ?? everything
          +|   oh --format [path]  # format path ?? everything
          +|   oh --run [path]     # runs code in path ?? looks for a `main_` function
          +|                       #    according to path rules (see dir/file.oh logic)
          +|   oh --test [path]    # runs tests in path ?? everything
          +|   # )=actions=|
          +|   # |==modes==(
          +|   # the default mode is --debug.
          +|   oh --release [path] # handles path ?? everything in release mode
          +|   oh --debug [path]   # handles path ?? everything in debug mode
          +|   # )==modes==|
          +|   # ]=options=|

options_mode_: one_of_{release:, debug:}
options_action_: any_of_{format:, compile:, run:, test:}

# TODO: make into a builder
options_: @private
[    mode?;
     action?;
     path?; valid_file_path_
]
{    m_(arguments{str_};): hm_{ok_: m_, er_: str_}
          options;
          arguments each str.
               hm: what str
                    # abc{
                    "--compile" {options action_(_ compile)}
                    "--debug" {options mode_(_ debug)}
                    "--format" {options action_(_ format)}
                    "--release" {options mode_(_ release)}
                    "--test" {options action_(_ test)}
                    # }xyz
                    # TODO: if `arg` starts with `--` or `-` then we should
                    #         probably give a different error.
                    arg. {options path_(arg)}
               hm assert_()
          ok_(options)

     ;;mode_(mode.): hm_{ok_: null_, er_: str_}
          if m mode != null
               er_("already have set mode ${m mode}")
          else
               m mode = mode
               ok_()

     ;;action_(action.): hm_{ok_: null_, er_: str_}
          if m action & action
               er_("already have set action with ${action}, currently ${m action}")
          else
               m action |= action
               ok_()

     ;;path_(str.): hm_{ok_: null_, er_: str_}
          # TODO: i like the `orelse` logic of zig or v-lang, i think
          # that's more readable than `map_(${str_($er)}) assert_()`
          valid_file_path. file_path_(str) resolve_() or FILE_er.
               return. er_(FILE_er)
          assert_(valid_file_path exists_(), er: "file ${valid_file_path} does not exist")
          if m path != null
               # currently unsupported.
               # it's a bit confusing how we'd handle `--run` specifically;
               # if there are multiple files do we run them all sequentially,
               # then run their tests?  if the path is a directory, we look for
               # a `main_` file, but if you also pass in a regular file path,
               # do we look for a `main_` file and also run the regular file?
               er_("we currently do not support passing in multiple paths")
          else
               m path = valid_file_path
               ok_()

     ::action_(): action_
          m action ?? _ format | _ compile | _ run | _ test

     ::mode_(): mode_
          m mode ?? _ debug

     ::path_(): valid_file_path_
          m path ?? os cwd_()

     mode_: options_mode_
     action_: options_action_
}
