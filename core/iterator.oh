iterator_{of_:, from_: null_, can?: null}: []
{    ;;next_(from:)?: of_

     ::peek_{require: can has_peek_()}(from:)?: of_

     # deletes the next value (i.e., at `peek`).
     ;;delete_next_{require: can has_delete_()}(from;): null_

     ;;remove_next_{require: can has_remove_()}(from;)?: of_

     # inserts the value `of` *before* the `next_()` value.
     # however, we will *NOT* iterate over this new value; i.e.,
     # the iterator will advance past this new value.
     ;;insert_{require: can has_insert_()}(from;, of.): hm_{ok_: null_, from_ er_}
}

can_: any_of_
{    peek:
     delete:
     remove:
     # TODO: we could add an `er_` class to `insert` if we need it,
     # but that would require putting this into the `iterator_` body
     # and passing in additional `insert_er_` generics.
     insert:
}
