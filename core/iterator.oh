iterator_[of_, from_: null_, can: none]: []
{    ;;next_(from:)?: of_

     # TODO: should we double-down on overloads?
     # `::next_` instead of `::peek_`?
     ::peek_[require: can has_peek_()](from:)?: of_

     # deletes the next value (i.e., at `peek`).
     ;;delete_next_[require: can has_delete_()](from;): null_

     ;;remove_next_[require: can has_remove_()](from;)?: of_

     # inserts the value `of` *before* the `next_()` value.
     # however, we will *NOT* iterate over this new value; i.e.,
     # the iterator will advance past this new value.
     ;;insert_[require: can has_insert_()](from;, of.): hm_[ok_: null_, from_ er_]
}

can_: choose_
[    peek:
     delete:
     remove:
     insert:
]
