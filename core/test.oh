# TODO: define the `@test_panics` macro
# TODO: define the `@compile_panics` macro

@test(Ast;): hm[er: str]
    Node; Ast next()
    @Bad_declaration Er: 'Expected `@test "test name":` with `{...}` or indented block'
    Binary; Node! binary_operation() assert(@Bad_declaration Er)
    assert(Binary operator == Op_declare_readonly, @Bad_declaration Er)
    Atomic; Binary Left! atomic() assert(@Bad_declaration Er)
    Test_name: Atomic! simple_string() assert(@Bad_declaration Er)
    Block; Binary Right! block() assert(@Bad_declaration Er)
    # TODO: there might be something we need to do to force Test_name into this string
    # before even @statement gets a hold of it.  but this will be a common need, so
    # maybe we can have a special syntax here, e.g., `@"Test push(${Test_name})"`, or
    # we just force @statement to evaluate the interpolation first, then parse.
    Block prepend(@statement("Test push(${Test_name})"))
    Block append(@statement("Test pop(${Test_name})"))
    if !@in_scope(Test)
        Block prepend(@statement("Test; test_context"))
        # TODO: @statement builds something like this:
        # statement
        # (   binary_operation
        #     (   Left: identifier("Test")
        #         Op_declare_writable
        #         Right: identifier("test_context")
        #     )
        # )
        
    # TODO: add Block back into the Ast

@private
test_context: [@protected Printed; array[str], @protected Name; str]
{   i()
    {   print
    }
    # TODO

    ;;push(Str: str):
        My Name &= Str

    ;;pop(Str. str):
        My Name
}
        

test[of]: [Of]
{   i(~T.): test[t]
        [T!]

    ::==(Of): bool
        if My Of == Of
            return True
        panic("expected ${My Of} == ${Of}")
        False

    ::!=(Of): bool
        if My Of != Of
            return True
        panic("expected ${My Of} != ${Of}")
        False

    ::>=(Of): bool
        if My Of >= Of
            return True
        panic("expected ${My Of} >= ${Of}")
        False

    ::<=(Of): bool
        if My Of <= Of
            return True
        panic("expected ${My Of} <= ${Of}")
        False
        
    ::>(Of): bool
        if My Of > Of
            return True
        panic("expected ${My Of} > ${Of}")
        False

    ::<(Of): bool
        if My Of < Of
            return True
        panic("expected ${My Of} < ${Of}")
        False
}

@test "==":
    @test "works for ints":
        test(5) == 5
        test(10) == 10

    @test_panics "expected 5 == 6":
        test(5) == 6

@test "!=":
    @test "works for ints":
        test(5) != 50
        test(10) != 12

    @test_panics "expected 3 != 3":
        test(3) != 3

@test ">=":
    @test "works for ints":
        test(5) >= 3
        test(10) >= 10

    @test_panics "expected 5 >= 6":
        test(5) >= 6

@test "<=":
    @test "works for ints":
        test(5) <= 6
        test(12) <= 12

    @test_panics "expected 7 <= 6":
        test(7) <= 6

@test "<":
    @test "works for ints":
        test(5) < 6
        test(10) < 11

    @test_panics "expected 7 < -1":
        test(7) < -1

@test ">":
    @test "works for ints":
        test(5) > 3
        test(20) > 19

    @test_panics "expected -1 > 1":
        test(-1) > 1
