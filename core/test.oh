# TODO: define the `@test_panics` macro
# TODO: define the `@compile_panics` macro

@test: hm_[er_: str_]
    # TODO: do we need to get `ast` as a singleton or just use it?
    # maybe by default it is available to `@macros`.
    BAD_DECLARATION_er: 'expected `@test "test name":` with `{...}` or indented block'
    node; ast parse_next_() assert_(BAD_DECLARATION_er)

    binary; node! binary_operation_() assert_(BAD_DECLARATION_er)
    assert_(binary operator == op_declare_readonly, BAD_DECLARATION_er)

    # `test_name` includes quotes, e.g., `"whatever \"test name\" you want"`:
    test_name: binary left! string_() assert_(BAD_DECLARATION_er)
    test_block; binary right! block_() assert_(BAD_DECLARATION_er)

    if !ast includes_(tests)
        return

    # Create a unique name for the test block so we can use it in code.
    test_block_name: ast unique_variable_()
    ast add_
    (   ast_ statement_
        (   ast_ binary_operation_
            (   left: identifier_(test_block_name)
                op_declare_readonly
                right: test_block
            )
        )
    )

    # TODO: it might be cleaner to just define this statement:
    # block; block_
    # (   ast_ statement_
    #     (   ast_ binary_operation_
    #         (   left: ast_ binary_operation_
    #             (   left: identifier_("context")
    #                 op_access
    #                 right: identifier_("run")
    #             )
    #             op_access
    #             right: parentheses_
    #             (   ...
    #                 test_block
    #             )
    #         )
    #     )
    # )
    block; block_
    (   ast_ statement_("context run_(${test_name}, ${test_block_name}) assert_()"))
    )

    if ast in_scope_("context")
        # TODO: for running tests in parallel with the same parent state,
        # we probably could fork here.  but that's a bit hacky on Windows.
        ast add_(ast_ statement_(.block))
        return

    # statement, via string, builds something like this:
    # ast_ statement_
    # (   ast_ binary_operation_
    #     (   left: identifier_("context")
    #         op_declare_writable
    #         right: identifier_("test_context_")
    #     )
    # )
    block prepend_(ast_ statement_("context; test_context_"))

    ast add_(test. block)

@protected
test_context_: [@protected printed; array_[str_], @protected name; str_]
{   ;;run_(str., block[hm_[ok_: null_, ~er_]]): hm_[ok_: null_, er_]
        str strip_()
        m push_(:str)
        hm: block run_()
        m pop_(:str)
        hm

    @private
    ;;push_(str:):
        m name &= str

    @private
    ;;pop_(str:):
        assert_(m name ends_with_(str)) ?? panic_("test_context needs to match push/pop")
        m name count_bytes_(m name count_bytes_() - str count_bytes_())
        if m name ends_with_(' ')
            m name pop_()
}

test_[of_]: [of;, oh_info:, transformation; str_]
{   g_(~t., oh_info. oh_info_ caller_(), transformation. ""): g_[t_]
        [t, oh_info, transformation]

    # TODO: does this descope at the right time?  i think so as long
    # as we ensure that we don't hold a reference to it, like
    # `my_test: test_(5) == 6`
    # but that might be desired anyway, in case you want to check a bunch of results.
    ;;descope_(): null_
        @if of_ is bool_
            if !m of
                error_("${m oh_info}: expected ${m transformation}")
                panic_("expected ${m transformation}")
        @elif of_ is hm_
            if of is er:
                error_("${m oh_info}: expected ${m transformation}, got ${er}")
                panic_("expected ${m transformation} to be OK, got ${er}")
        @else
            if !m transformation
                error_("${m oh_info}: expected an expression like `test_(x) == 7`")

    @methods(of_) @each method:
        # `method arguments` will include `m:`, `m;`, or `m.`, so we don't
        # need to add `::`, `;;`, or `..` to the start here.
        @concat(method name)(...method arguments): test_[method returning_]
            transformation. str_ = "${m transformation} ${of_ string_(method)}"
            returning. @concat(method name)(...method arguments)
            # TODO: i think we need to plan for `m` to be descoped here.
            # TODO: maybe this method should be converted to `..` regardless of `m`.
            g_(returning, oh_info_ caller_(), transformation)
}

@test "==":
    @test "works for ints":
        test_(5) == 5
        test_(10) == 10

    @test_panics "expected (5 == 6) bool":
        test_(5) == 6

@test "!=":
    @test "works for ints":
        test_(5) != 50
        test_(10) != 12

    @test_panics "expected (3 != 3) bool":
        test_(3) != 3

@test ">=":
    @test "works for ints":
        test_(5) >= 3
        test_(4) >= 4
        test_(10) >= 10

    @test_panics "expected (5 >= 6) bool":
        test_(5) >= 6

@test "<=":
    @test "works for ints":
        test_(5) <= 6
        test_(7) <= 7
        test_(12) <= 12

    @test_panics "expected (7 <= 6) bool":
        test_(7) <= 6

@test "<":
    @test "works for ints":
        test_(5) < 6
        test_(10) < 11

    @test_panics "expected (7 < -1) bool":
        test_(7) < -1

    @test_panics "expected (-1 < -1) bool":
        test_(-1) < -1

@test ">":
    @test "works for ints":
        test_(5) > 3
        test_(20) > 19

    @test_panics "expected (-1 > 1) bool":
        test_(-1) > 1

    @test_panics "expected (1 > 1) bool":
        test_(1) > 1
