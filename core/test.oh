# TODO: define the `@test_panics` macro
# TODO: define the `@compile_panics` macro

@test(Ast;): hm[er: str]
    @Bad_declaration Er: 'Expected `@test "test name":` with `{...}` or indented block'
    Node; Ast parse_next() assert(@Bad_declaration Er)

    Binary; Node! binary_operation() assert(@Bad_declaration Er)
    assert(Binary operator == Op_declare_readonly, @Bad_declaration Er)

    # `Test_name_string` includes quotes, e.g., `"whatever \"test name\" you want"`:
    Test_name: Binary Left! string() assert(@Bad_declaration Er)
    Test_block; Binary Right! block() assert(@Bad_declaration Er)

    if Ast release()
        return

    # Create a unique name for the test block so we can use it in code.
    Test_block_name: Ast unique_variable()
    Ast add
    (   statement
        (   binary_operation
            (   Left: identifier(Test_block_name)
                Op_declare_readonly
                Right: Test_block
            )
        )
    )

    # TODO: it might be clearer to just define this statement:
    # Block; block
    # (   statement
    #     (   binary_operation
    #         (   Left: binary_operation
    #             (   Left: identifier("Test")
    #                 Op_access
    #                 Right: identifier("run")
    #             )
    #             Op_access
    #             Right: enclosed
    #             (   ...
    #                 Test_block
    #             )
    #         )
    #     )
    # )
    Block; block
    (   statement("Test run(${Test_name}, ${Test_block_name})"))
    )

    if !Ast in_scope("Test")
        Block prepend(statement("Test; test_context"))
        # statement, via string, builds something like this:
        # statement
        # (   binary_operation
        #     (   Left: identifier("Test")
        #         Op_declare_writable
        #         Right: identifier("test_context")
        #     )
        # )
        # `
        Ast add(Test. Block!)
    else
        Ast add(statement(Block!))

@protected
test_context: [@protected Printed; array[str], @protected Name; str]
{   i()
    {   print
    }
    # TODO

    ;;run(Str: str, 

    @private
    ;;push(Str: str):
        My Name &= Str

    @private
    ;;pop(Str: str):
        assert(My Name ends_with(Str)) ?? panic("test_context needs to match push/pop")
        My Name count(My Name count() - Str count())
        if My Name ends_with(' ')
            My Name pop()
}
        

test[of]: [Of]
{   i(~T.): test[t]
        [T!]

    ::==(Of): bool
        if My Of == Of
            return True
        panic("expected ${My Of} == ${Of}")
        False

    ::!=(Of): bool
        if My Of != Of
            return True
        panic("expected ${My Of} != ${Of}")
        False

    ::>=(Of): bool
        if My Of >= Of
            return True
        panic("expected ${My Of} >= ${Of}")
        False

    ::<=(Of): bool
        if My Of <= Of
            return True
        panic("expected ${My Of} <= ${Of}")
        False
        
    ::>(Of): bool
        if My Of > Of
            return True
        panic("expected ${My Of} > ${Of}")
        False

    ::<(Of): bool
        if My Of < Of
            return True
        panic("expected ${My Of} < ${Of}")
        False
}

@test "==":
    @test "works for ints":
        test(5) == 5
        test(10) == 10

    @test_panics "expected 5 == 6":
        test(5) == 6

@test "!=":
    @test "works for ints":
        test(5) != 50
        test(10) != 12

    @test_panics "expected 3 != 3":
        test(3) != 3

@test ">=":
    @test "works for ints":
        test(5) >= 3
        test(10) >= 10

    @test_panics "expected 5 >= 6":
        test(5) >= 6

@test "<=":
    @test "works for ints":
        test(5) <= 6
        test(12) <= 12

    @test_panics "expected 7 <= 6":
        test(7) <= 6

@test "<":
    @test "works for ints":
        test(5) < 6
        test(10) < 11

    @test_panics "expected 7 < -1":
        test(7) < -1

@test ">":
    @test "works for ints":
        test(5) > 3
        test(20) > 19

    @test_panics "expected -1 > 1":
        test(-1) > 1
