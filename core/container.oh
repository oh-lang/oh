container_
{    of_:
     at_:
     count_: select_count_ = arch_ count_
     require: of_ is !null_
     PROVIDED_er_: er_
     require: er_ in PROVIDED_er_
}: all_of_
{    hazable{at_}:
}
{    ::count_(): count_

     !!(m:): bool_
          count_(m) > 0

     # TODO: think about the mutable nullable API, we don't want to
     # have inconsistent implementations between arrays and lots.
     # maybe rely on `pop_` and `remove_`

     # get a nullable reference to an element.
     ::[at.]: (of?:)

     #[#
     safe API for creating a reference at `at`.
     this will add a default `of` if `at` is not already in the container.
     can return an error if the container runs out of memory
     or for other container-specific reasons.
     #]#
     ;;[at.]: hm_{(of;)}

     #[#
     get a non-null reference to an element.
     this will add a default `of` if `at` is not already in the container.
     mooting this element will not remove the element from the container,
     but will reset it to the default.
     #]#
     ;;[at.]: (of;)

     # returns the element at `at` or null if not present,
     # removing it from the container while doing so.
     # TODO: good way to do "define one of ;;pop, ;;swap, etc."
     #        and to indicate that in the code so we can rely on it
     #        in the other "undefined" methods.
     #        maybe `if @specialized ;;pop_ { ... }`
     #        and `@require: @specialized ;;pop_ || @specialized ;;swap_`...
     #        this `@require` is only needed for a non-abstract class.
     # TODO: i'm not a big fan of `pop`, maybe `remove_(at.)?: of_` and `remove_(all. of_): count_`
     # or we can do `give_(of)` (to add) and `take_(at)` (to remove) so that we have matching lengths.
     # `take` could have an iterator overload
     # `lot give_(at. "hello", 123)` -- don't love this compared to `insert_` and `remove_` though.
     # `lot insert_(at. "hello", 123)`, `lot remove_("hello")`
     ;;pop_(at.)?: of_

     # TODO: `::min_()`, `::max_()`, and `::order_(count.)` methods.
     #        these should just pass through to the iterator, but `{require: of_ is orderable_}`

     :;.each_(blockable{defining_: (of_:;.), ~t_}:)?: t_

     :;.each_(blockable{defining_: (at::., of:;.), ~t_}:)?: t_

     # can implicitly convert to an iterator (with writeable/readonly references).
     ;:iterator_(): iterator_{(at:, of;:)}

     # iterate over keys/`at`s.
     ::ats_(): iterator_{(at:)}

     # iterate over values.
     ;:ofs_(): iterator_{(of;:)}

     @alias ::has_(at): m[at] != null
     @alias ::contains_(at): m[at] != null

     hm_{of_:}: hm_{ok_: of_, PROVIDED_er_}
}

# TODO: we don't want these in the global namespace; maybe in the `core` directory
# we only automatically export classes that are named after the file,
# e.g., `container.oh::container_`?
er_: one_of_
{    out_of_memory:
     # etc.
}

