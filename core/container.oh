container_
{    of_:
     at_:
     count_: select_count_ = arch_ count_
     require: of_ is !null_
     PROVIDED_er_: er_
     require: er_ in PROVIDED_er_
     ordered_: bool_ = true
}:   all_of_
{    hazable{at_};
     removable{of_, count_, ordered};
}
{    ::count_(): count_

     !!(m:): bool_
          count_(m) > 0

     # TODO: think about the mutable nullable API, we don't want to
     # have inconsistent implementations between arrays and lots.

     # get a nullable reference to an element.
     ::[at.]: (of?:)

     #[#
     safe API for creating a reference at `at`.
     this will add a default `of` if `at` is not already in the container.
     can return an error if the container runs out of memory
     or for other container-specific reasons.
     #]#
     ;;[at.]: hm_{(of;)}

     #[#
     get a non-null reference to an element.
     this will add a default `of` if `at` is not already in the container.
     mooting this element will not remove the element from the container,
     but will reset it to the default.
     #]#
     ;;[at.]: (of;)

     # removes any convenient element from the container; when insertion-ordered
     # it's always the last element.  returns `null` if not present.
     ;;remove_()?: of_

     # returns the element at `at` or null if not present,
     # removing it from the container while doing so.
     # TODO: good way to do "define one of ;;remove, ;;swap, etc."
     #        and to indicate that in the code so we can rely on it
     #        in the other "undefined" methods.
     #        maybe `if @specialized ;;remove_ { ... }`
     #        and `@require: @specialized ;;remove_ || @specialized ;;swap_`...
     #        this `@require` is only needed for a non-abstract class.
     ;;remove_(at.)?: of_

     # returns the number of elements removed when matching values of `all`.
     ;;remove_(all: of_): count_

     # TODO: `::min_()`, `::max_()`, and `::order_(count.)` methods.
     #        these should just pass through to the iterator, but `{require: of_ is orderable_}`

     :;.each_(blockable{defining_: (of_:;.), ~t_}:)?: t_

     :;.each_(blockable{defining_: (at::., of:;.), ~t_}:)?: t_

     # can implicitly convert to an iterator (with writeable/readonly references).
     ;:iterator_(): iterator_{(at:, of;:)}

     # iterate over keys/`at`s.
     ::ats_(): iterator_{(at:)}

     # iterate over values.
     ;:ofs_(): iterator_{(of;:)}

     @alias ::has_(at): m[at] != null
     @alias ::contains_(at): m[at] != null

     hm_{of_:}: hm_{ok_: of_, PROVIDED_er_}
}

# TODO: we don't want these in the global namespace; maybe in the `core` directory
# we only automatically export classes that are named after the file,
# e.g., `container.oh::container_`?
er_: one_of_
{    out_of_memory:
     # etc.
}

