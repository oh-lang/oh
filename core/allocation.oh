@final
allocation_
[    of_
     # if not null, we allocate just enough space for this extra data
     # just before the buffer of `of_` values.  there can be multiple
     # `of` values, but only ever one instance of `header` is added.
     header_: null_
     # determines the maximum size of the allocation, and
     # makes indexing this allocation potentially more efficient.
     count_: select_count_
     # whether to include capacity inside this allocation.
     # if not, you need to supply it when running various methods.
     local_capacity: bool_ = true
]:
[    @private m:
     [    ptr[of_];
          capacity[require: local_capacity];
     ]
]
{    ::capacity_[require: local_capacity](): m capacity

     ::!(): bool_
          m ptr == null

     # ensure you free any elements that were initialized
     # if the new capacity is smaller than the old capacity.
     # this data structure does not keep track of which elements are initialized.
     ;;capacity_[require: local_capacity](new. capacity_): hm_[null_]
          m capacity_(new, old. m capacity_())

     @private_if(local_capacity)
     ;;capacity_(new. capacity_, old. capacity_): hm_[null_]
          required_bytes: memory_ = assert_
          (    new * of_ memory_() + header_bytes
               er: out_of_memory
          )
          if old == 0
               ptr[u8_]: required_bytes allocate_() assert_(er: out_of_memory)
               m ptr = ptr + header_bytes
          else
               ptr[u8_]; m ptr
               ptr -= header_bytes
               required_bytes reallocate_(;ptr) assert_(er: out_of_memory)
               m ptr = ptr + header_bytes

     # make sure that this element is already initialized.
     # this will return an error if `offset` is out of bounds.
     ;:at_[require: local_capacity](offset.): hm_[(of;:)]

     ;;initialize_[require: local_capacity](offset., of.): hm_[null_]

     ;;deinitialize_[require: local_capacity](offset.): hm_[null_]

     ;;remove_[require: local_capacity](offset.): hm_[of_]

     # TODO: non-local_capacity versions of the above, call them.

     @private
     header_bytes: memory_
          @if header_ is null_
               0
          @else
               bytes: memory_(header_)
               word_memory: memory_(arch_ word_)
               need_one_more_word: bytes %% word_memory != 0
               return (bytes // word_memory + need_one_more_word) * word_memory

     # if not allocated, this can return an error for `::`;
     # it can also return an error for `;;` if we run out of memory.
     ;:header_[require: header_ is not_[null_]](): hm_[(header;:)]
          if !m
               if @readonly(m)
                    return er_(not_allocated)
               else
                    m capacity_(small_capacity) assert_()
          # TODO: is this the best way to assert using the no-throw version of `header_`?
          # or should we have a cast like `(m where !!m) header_()` or `with`
          # or maybe `assume_(!!m)`, e.g., `assume_(!!m) {m header_()}`
          debug assert_(!!m)
          m header_()

     # the no-throw version to get the `header`, when `m` is truthy.
     ;:header_[require: header_ is not_[null_]](): (header;:) where !!m
          ptr[u8_]: m ptr  # TODO: casting??
          ptr -= header_bytes  # `header_` starts before the `of_` buffer
          ptr to_()

     # TODO: update based on size of `of_`
     small_capacity: 4

     capacity_: count_
     offset_: offset_[count_]

     hm_[of_]: hm_[of_]
}

hm_[of_]: hm_
[    ok_: of_
     er_: container_ er_
]
