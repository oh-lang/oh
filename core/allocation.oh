@final
#allocation
[    #of:
     # determines the maximum size of the allocation, and
     # makes indexing this allocation potentially more efficient.
     # when using an `#index_count`, negative indices are used for "from the back";
     # when using an `#offset_count`, negative indices are not permitted, and
     # `#offset max` (should be -1, wrapped) is reserved as an invalid offset.
     # the downside of `#index` is that the max capacity is `#index max_count`,
     # which is half the max capacity of `#offset max_count`.
     #capacity: #select_count
     # if not null, we allocate just enough space for this extra data
     # just before the buffer of `#of` values.  there can be multiple
     # `of` values, but only ever one instance of `header` is added.
     # TODO: we probably can infer `#header: #null` implies `#header: #any = #null`.
     #header: #any = #null
     # whether to put capacity locally inside this allocation.
     # if `on_heap`, it gets added to the `#combined_header`
     capacity_site: #~ local
]:
[    @private m:
     [    of_ptr;
          capacity[require: capacity_site is_local()];
     ]
]
{    ::capacity(): #capacity
          if capacity_site is_local()
               #capacity(m capacity)
          else
               m combined_header() map
               (    ${#capacity($ok capacity)}
                    ${$_er, 0}
               )

     # this notation might be more concise and understandable: `!m: #bool`
     ::!(): #bool
          m of_ptr == null

     # ensure you free any elements that were initialized
     # if the new capacity is smaller than the old capacity.
     # this data structure does not keep track of which elements are initialized.
     ;;capacity(capacity.): #hm[#null]
          m capacity(new. capacity, old. m capacity())

     @private
     ;;capacity(new. #capacity, old. #capacity): #hm[#null]
          # TODO: adjust for `#header data_alignment` and `#of data_alignment`.
          required_memory: #memory = assert
          (    new * #memory(#of) + #memory(#combined_header)
               #er out_of_memory
          )
          if old == 0
               ptr[#u8]. required_memory allocate() assert(#er out_of_memory)
               m ptr(ptr, new[require: capacity_site is_on_heap()])
          else
               ptr[#u8]. m ptr()
               required_memory reallocate(;ptr) assert(#er out_of_memory)
               m ptr(ptr, new[require: capacity_site is_on_heap()])

          if capacity_site is_local()
               m capacity = new


     # make sure that this element is already initialized;
     # this `allocation` does not keep track of which elements are initialized.
     # this will return an error if `offset` is out of bounds.
     # TODO: the `#hm` doesn't seem to be in the right spot since `offset` is lazily evaluated.
     #[#
     ;:at(offset.): #hm[(of;:)]
          refer
          (    m
               at. offset
               ${assert($at < m capacity()), $o of_ptr + $at}
          )
     #]#

     # if doing things that require the pointer to be initialized,
     # make sure that this element is already initialized;
     # this `allocation` does not keep track of which elements are initialized.
     # this will return an error if `offset` is out of bounds and we can't resize to encompass `offset`.
     ;;at(offset.): #hm[#ptr[#of]]
          if offset >= m capacity()
               m capacity(offset + 1) assert()
          m of_ptr + offset

     # if doing things that require the pointer to be initialized,
     # make sure that this element is already initialized;
     # this `allocation` does not keep track of which elements are initialized.
     # this will return an error if `offset` is out of bounds.
     ::at(offset.): #hm[#ptr[#of]]
          assert(offset < m capacity(), #er out_of_bounds)
          m of_ptr + offset

     ;:at(in_bounds. #offset): #ptr[#of]
          debug assert(in_bounds < m capacity())
          m of_ptr + offset

     ::header[require: #header](): #hm[#(header:)]
          if m
               ok(m header())
          else
               #er unallocated

     ;;header[require: #header](): #hm[#(header;)]
          if !m
               m capacity(small_capacity) assert()
          debug assert(!!m)
          ok(m header())

     # gets the header when `m` is truthy.
     ;:header[require: #header](): #(header;:) where !!m
          m combined_header() header

     @private
     ;:combined_header[require: #header or capacity_site is_on_heap()]: (combined_header;:)
          m ptr() to()

     @private
     ;;ptr(ptr[#u8]., capacity[require: capacity_site is_on_heap()].): #null
          if ptr == null
               m of_ptr = null
          else
               # TODO: adjust for data alignment
               m of_ptr = ptr + #memory(#combined_header)
               @if capacity_site is_on_heap()
                    m combined_header() capacity = capacity

     @private
     ::ptr(): #ptr[#u8] where !!m
          ptr[#u8]; m of_ptr  # TODO: casting??
          # TODO: adjust for data alignment
          ptr -= #memory(#combined_header)
          ptr

     @private
     ::ptr(): #ptr[#u8] where !m
          null

     # TODO: update based on size of `of_`
     small_capacity: 4

     @private
     #combined_header: @if header_ or capacity_site is_on_heap_()
          #[   header[require: #header];
               capacity[require: capacity_site is_on_heap()];
          ]
     @else
          #null

     #er: #container #er
     #hm[#of:]: #hm[#ok: #of, #er]

     # use an alias so we can do, e.g., `#allocation[capacity_site on_heap]`
     # to specify `capacity_site`
     #capacity_site: @distinct #memory #site

     #offset: #capacity #offset
     #index: #capacity #index

     @private
     #of_ptr: #ptr[#of]
}
