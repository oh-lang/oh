@final
allocation_
{    of_:
     # determines the maximum size of the allocation, and
     # makes indexing this allocation potentially more efficient.
     # when using an `index_count_`, negative indices are used for "from the back";
     # when using an `offset_count_`, negative indices are not permitted.
     # the downside of `index_` is that the max capacity is `index_ max_count`,
     # which is half the max capacity of `offset_ max_count`.
     capacity_: select_count_
     # if not null, we allocate just enough space for this extra data
     # just before the buffer of `of_` values.  there can be multiple
     # `of` values, but only ever one instance of `header` is added.
     # TODO: we probably can infer `header_: null_` implies `header_: any_ = null_`.
     header_: any_ = null_
     # whether to put capacity locally inside this allocation.
     # if `on_heap`, it gets added to the `combined_header_`
     capacity_site: _ local
}:
[    @private m:
     [    of_ptr;
          maybe_capacity{require: capacity_site is_local_()};
     ]
]
{    ::capacity_(): capacity_
          if capacity_site is_local_()
               capacity_(m maybe_capacity, has_ptr. m of_ptr != null)
          else
               # TODO: add combined_header method
               m combined_header_() map_
               (    fn_(ok:) capacity_(ok maybe_capacity, has_ptr: true)
                    fn_(_er:): 0
               )

     # in case `capacity_` is an `index_count_`, we can use `capacity_ of_`
     # directly as the capacity of this allocation.
     # otherwise, if `capacity_` is an `offset_count_`, `capacity_ of_`
     # is too small in one case, i.e., when at max capacity.
     # in that case, `maybe_capacity = 0` but `of_ptr != null`,
     # which we'll interpret as max capacity.
     @private
     maybe_capacity_: capacity_ of_

     @private
     capacity_(maybe_capacity., has_ptr. bool_): capacity_
          if capacity_ indexable
               debug assert_(capacity_(maybe_capacity))
          else
               if maybe_capacity
                    _(maybe_capacity)
               elif has_ptr
                    _ max_()
               else
                    _ min_()

     # this notation might be more concise and understandable: `!m: bool_`
     ::!(): bool_
          m of_ptr == null

     # ensure you free any elements that were initialized
     # if the new capacity is smaller than the old capacity.
     # this data structure does not keep track of which elements are initialized.
     ;;capacity_(capacity.): hm_{null_}
          m capacity_(new. capacity, old. m capacity_())

     @private
     ;;capacity_(new. capacity_, old. capacity_): hm_{null_}
          required_bytes: memory_ = assert_
          (    new * of_ memory_() + combined_header_bytes
               er_ out_of_memory
          )
          if old == 0
               ptr{u8_}. required_bytes allocate_() assert_(er_ out_of_memory)
               m ptr_(ptr, new{require: capacity_site is_on_heap_()})
          else
               ptr{u8_}. m ptr_()
               required_bytes reallocate_(;ptr) assert_(er_ out_of_memory)
               m ptr_(ptr, new{require: capacity_site is_on_heap_()})

          if capacity_site is_local_()
               m maybe_capacity = truncate_(new)


     # make sure that this element is already initialized;
     # this `allocation` does not keep track of which elements are initialized.
     # this will return an error if `offset` is out of bounds.
     # TODO: the `hm` doesn't seem to be in the right spot since `offset` is lazily evaluated.
     #[#
     ;:at_(offset.): hm_{(of;:)}
          refer_
          (    m
               at. offset
               {assert_($at < m capacity_()), to_($o of_ptr + $at)}
          )
     #]#

     # if doing things that require the pointer to be initialized,
     # make sure that this element is already initialized;
     # this `allocation` does not keep track of which elements are initialized.
     # this will return an error if `offset` is out of bounds and we can't resize to encompass `offset`.
     ;;at_(offset.): hm_{ptr_{of_}}
          if offset >= m capacity_()
               m capacity_(offset + 1) assert_()
          if m of_ptr == null
               null
          else
               m of_ptr + offset

     # if doing things that require the pointer to be initialized,
     # make sure that this element is already initialized;
     # this `allocation` does not keep track of which elements are initialized.
     # this will return an error if `offset` is out of bounds.
     ::at_(offset.): hm_{ptr_{of_}}
          assert_(offset < m capacity_(), er_ out_of_bounds)
          if m of_ptr == null
               null
          else
               m of_ptr + offset

     ;:at_(in_bounds. offset_): ptr_{of_}
          debug assert_(in_bounds < m capacity_())
          m of_ptr + offset

     ::header_{require: header_}(): hm_{(header:)}
          if m
               ok_(m header_())
          else
               er_ unallocated

     ;;header_{require: header_}(): hm_{(header;)}
          if !m
               m capacity_(small_capacity) assert_()
          with !!m
               ok_(m header_())

     # gets the header when `m` is truthy.
     ;:header_{require: header_}(): (header;:) where !!m
          (combined_header;:) = m ptr_() to_()
          combined_header header

     @private
     ;;ptr_(ptr{u8_}., capacity{require: capacity_site is_on_heap_()}.): null_
          if ptr == null
               m of_ptr = null
          else
               m of_ptr = ptr + combined_header_bytes
               @if capacity_site is_on_heap_()
                    (combined_header;) = ptr to_()
                    combined_header maybe_capacity = truncate_(capacity)

     @private
     ::ptr_(): ptr_{u8_} where !!m
          ptr{u8_}: m of_ptr  # TODO: casting??
          ptr -= combined_header_bytes  # if present, `combined_header_` starts before the `of_` buffer
          ptr

     @private
     ::ptr_(): ptr_{u8_} where !m
          null

     @private
     combined_header_bytes: memory_
          if combined_header_
               at_least_memory: memory_(combined_header_)
               word_memory: memory_(arch_ word_)
               # TODO: maybe just `ceil_(at_least_memory / word_memory) * word_memory`??
               need_one_more_word: at_least_memory %% word_memory != 0
               (at_least_memory // word_memory + need_one_more_word) * word_memory
          else
               0

     # TODO: update based on size of `of_`
     small_capacity: 4

     @private
     combined_header_: if header_ or capacity_site is_on_heap_()
          [    header{require: header_};
               maybe_capacity{require: capacity_site is_on_heap_()};
          ]
     else
          null_

     er_: container_ er_
     hm_{of_:}: hm_{ok_: of_, er_}

     # use an alias so we can do, e.g., `allocation_{capacity_site_ on_heap}`
     # to specify `capacity_site`
     capacity_site_: @distinct memory_ site_

     offset_: capacity_ offset_
     index_{require: capacity_ indexable}: capacity_ index_

     @private
     of_ptr_: ptr_{of_}
}
