select_count_: select_[count64_, count32_, count16_, count8_]

count_arch_: count_[u_arch_]

count64_: count_[u64_]
count32_: count_[u32_]
count16_: count_[u16_]
count8_: count_[u8_]

@final
count_[of_: unsigned_primitive_]: all_of_
[   [@private value; of_]
    integer_
]
{   m(wrapping.): hm[m]
        if Wrapping <= max()
            [Value: Wrapping]
        else
            Unrepresentable

    ?:
    {   ::is(null): bool
            Value > max()
        Null: [Value: of(Wrapping: -1)]

        ::null_boxing(): of
            Value
        ;;null_boxing(Of;): null
            Value <-> Of
        ;;null_boxing(Of.): null
            Value = Of
    }

    @integer(Value)

    min(): m
        [Value: 0]

    max(): m
        [Value: signed[of] max() + 1]

    m(Signed. signed[of]): hm[m]
        [Value: of(.Signed) assert()]

    ::double_or_max(At_least. of): m
        if Value >= max() Value
            @cold_path
            # TODO: do we need a cast here `(M as m?) is_null()`
            if is_null()
                error("Count was null in ::double_or_max, assuming 0")
                [Value. At_least]
            else
                max()
        else
            [Value: max(At_least, Value * 2)]
}

hm[of]: hm[ok: of, number er]
