select_count_: select_[count64_, count32_, count16_, count8_]

count_arch_: count_[u_arch_]

count64_: count_[u64_]
count32_: count_[u32_]
count16_: count_[u16_]
count8_: count_[u8_]

@final
count_[of_: unsigned_primitive_]: all_of_
[   m_: [@private value; of_]
    integer_
]
{   m_(of.): hm_[m_]
        if of <= max_() value
            [value. of]
        else
            unrepresentable

    ?:
    {   ::is(null_): bool
            m value > max_() value
        null: [value: max_() value]

        ::null_boxing_(): of_
            m value
        ;;null_boxing_(of.): null_
            m value = of
    }

    @integer(m value)

    min_(): m_
        [value: 0]

    max_(): m_
        [value: signed_[of_] max_() + 1]

    m_(signed. signed_[of_]): hm_[m_]
        [value: of_(signed) assert_()]

    ::double_or_max_(): m_
        doubled_value: of_ = m value * 2
        [value: min_(max_() value, doubled_value)]
}

hm_[of_]: hm_[ok_: of_, number_ er_]
