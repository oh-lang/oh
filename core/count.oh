#[#
there are two types of counts; one that allows negative indexing
(which is generally the default) and one that doesn't.  e.g.,
an `index_count_` for a `i8_` index corresponds to  `u8_` type,
allowing counts from 0 to 128.  indices from 0 to 127 correspond
to elements 1 to 128, index -1 corresponds to the last element,
-2 to the second last, etc.  an `offset_count_` for a `u8_` offset
corresponds essentially to a `u9_` type, since we need to be
able to hold values from 0 to 256.  for an `offset_count_` type,
we do not permit negative indexing.  both `index_count_` and
`offset_count_` have a corresponding unsigned `offset_` type
(e.g., `u8_` for the above examples), but only `index_count_`
has a signed `index_` type.
#]#
@export
select_offset_count_: select_
{    count_{u64_, indexable: false}:
     count_{u32_, indexable: false}:
     count_{u16_, indexable: false}:
     count_{u8_, indexable: false}:
}
@export
select_index_count_: select_
{    count_{u64_, indexable: true}:
     count_{u32_, indexable: true}:
     count_{u16_, indexable: true}:
     count_{u8_, indexable: true}:
}
@export
select_count_: select_{select_index_count_:, select_offset_count_:}

@final
count_{of_: select_unsigned_, indexable: bool_ = true}: all_of_
{    @private m:
     [    value; unsigned_ bits_{of_ bits_ + !indexable}
     ]
     integer;
}
{    m_(of.): hm_{m_}
          if of <= max_() value
               [value. of]
          else
               unrepresentable

     m_(signed{of_}.): hm_{m_}
          [value: of_(signed) assert_()]

     # TODO: unsigned{of_}, should be foolproof for !indexable

     ?:
     {    ::is_(null_): bool_
               m value > max_() value

          null: [value: max_() value + 1]

          # be careful as some values become non-null here.
          :;null_boxing_(): (of:;)
               m value
     }

     @integer(m value)

     min_(): m_
          [value: 0]

     max_(): m_
          if indexable
               [value: of_ max_() // 2 + 1]
          else
               [value: value_(of_ max_()) + 1]

     ::double_or_max_(): m_
          if m < max_()
               [value: m value * 2]
          else
               max_()

     index_{require: indexable}: index_{signed_{of_}}
     offset_: offset_{of_}

     hm_{of_:}: hm_{ok_: of_, number_ er_}
}

@test "min_"
     assert_(count8_ max_()) == 0
     assert_(count16_ max_()) == 0
     assert_(count32_ max_()) == 0
     assert_(count64_ max_()) == 0

@test "max_"
     assert_(count8_ max_()) == 128
     assert_(count16_ max_()) == 32_768
     assert_(count32_ max_()) == 2_147_483_648
     assert_(count64_ max_()) == 9_223_372_036_854_775_808

@test "double_or_max_"
     @test "count8_"
          c_: count8_
          assert_(c_(0) double_or_max_()) == 0
          assert_(c_(3) double_or_max_()) == 6
          assert_(c_(63) double_or_max_()) == 126
          assert_(c_(64) double_or_max_()) == 128
          assert_(c_(65) double_or_max_()) == 128
          assert_(c_(65) double_or_max_()) == 128
          assert_(c_(127) double_or_max_()) == 128
          assert_(c_(128) double_or_max_()) == 128

@test "index and offset"
     @test "count8_"
          c_: count8_
          assert_(c_ index_) == index_{i8_}
          assert_(c_ offset_) == offset_{u8_}
