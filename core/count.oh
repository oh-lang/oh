#[#
there are two types of counts; one that allows negative indexing
(which is generally the default) and one that doesn't.  e.g.,
an `index_count_` for a `i8_` index corresponds to  `u8_` type,
allowing counts from 0 to 128.  indices from 0 to 127 correspond
to elements 1 to 128, index -1 corresponds to the last element,
-2 to the second last, etc.  an `offset_count_` for a `u8_` offset
corresponds essentially to a `u9_` type, since we need to be
able to hold values from 0 to 256.  for an `offset_count_` type,
we do not permit negative indexing.  both `index_count_` and
`offset_count_` have a corresponding unsigned `offset_` type
(e.g., `u8_` for the above examples), but only `index_count_`
has a signed `index_` type.
#]#
@export
select_count_: select_{select_index_count_:, select_offset_count_:}

# count options that are not negative indexable
@export
select_offset_count_: select_
{    offset_count64_:
     offset_count32_:
     offset_count16_:
     offset_count8_:
}
@export
offset_count_{of_}: count_{of_, indexable: false}
@export
offset_count8_: offset_count_{u8_}
@export
offset_count16_: offset_count_{u16_}
@export
offset_count32_: offset_count_{u32_}
@export
offset_count64_: offset_count_{u64_}

# count options that are negative indexable
@export
select_index_count_: select_
{    index_count64_:
     index_count32_:
     index_count16_:
     index_count8_:
}
@export
index_count_{of_}: count_{of_, indexable: true}
@export
index_count8_: index_count_{u8_}
@export
index_count16_: index_count_{u16_}
@export
index_count32_: index_count_{u32_}
@export
index_count64_: index_count_{u64_}

@final
count_{of_: select_unsigned_, indexable: bool_ = true}: all_of_
{    @private m:
     [    value; unsigned_ bits_{of_ bits_ + !indexable}
     ]
     integer;
}
{    m_{require: !indexable}(of.): m_
          [value. of]

     m_{require: indexable}(of.): hm_{m_}
          if of <= max_() value
               [value. of]
          else
               er_ unrepresentable

     m_(signed{of_}.): hm_{m_}
          [value: _(signed) assert_()]

     ?:
     {    ::is_(null_): bool_
               m value > max_() value

          null: [value: max_() value + 1]

          # be careful as some values become non-null here.
          :;null_boxing_(): (value:;)
               m value
     }

     @integer(m value)

     min_(): m_
          [value: 0]

     max_(): m_
          if indexable
               [value: of_ max_() // 2 + 1]
          else
               [value: _(of_ max_()) + 1]

     ::double_or_max_(): m_
          if m < max_() // 2
               [value: m value * 2]
          else
               max_()

     index_{require: indexable}: index_{signed_{of_}}
     offset_: offset_{unsigned_ bits_{of_ bits_ - indexable}}

     er_: number_ er_
     hm_{of_:}: hm_{ok_: of_, er_}
}

@test "min_"
     [
          index_count8_, index_count16_, index_count32_, index_count64_
          offset_count8_, offset_count16_, offset_count32_, offset_count64_
     ] each of_:
          assert_(of_) min_() == 0
          of; of_
          assert_(of) == 0
          assert_(of - 1) == number_ er_ unrepresentable

@test "max_"
     [
          [index_count8_, 1<<7]
          [index_count16_, 1<<15]
          [index_count32_, 1<<31]
          [index_count64_, 1<<63]
          [offset_count8_, 1<<8]
          [offset_count16_, 1<<16]
          [offset_count32_, 1<<32]
          [offset_count64_, 1<<64]
     ] each [of_, int]:
          assert_(of_) max_() == int
          of; _ max_()
          assert_(of + 1) == number_ er_ unrepresentable

@test "double_or_max_"
     @test "index_count8_"
          c_: index_count8_
          assert_(c_(0) double_or_max_()) == 0
          assert_(c_(3) double_or_max_()) == 6
          assert_(c_(63) double_or_max_()) == 126
          assert_(c_(64) double_or_max_()) == 128
          assert_(c_(65) double_or_max_()) == 128
          assert_(c_(65) double_or_max_()) == 128
          assert_(c_(127) double_or_max_()) == 128
          assert_(c_(128) double_or_max_()) == 128

@test "index and offset"
     @test "index_count8_"
          c_: index_count8_
          assert_(c_ index_) == index_{i8_}
          assert_(c_ offset_) == offset_{u7_}

     @test "offset_count8_"
          c_: offset_count8_
          assert_(c_ offset_) == offset_{u8_}
