select_count_: select_[count64_, count32_, count16_, count8_]

count_arch_: count_[u_arch_]

count64_: count_[u64_]
count32_: count_[u32_]
count16_: count_[u16_]
count8_: count_[u8_]

@final
count_[of_: unsigned_primitive_]: all_of_
[   m_: [@private value; of_]
    integer_
]
{   m_(of.): hm_[m_]
        if of <= max_() value
            [value. of]
        else
            unrepresentable

    ?:
    {   ::is(null_): bool
            m value > max_() value
        null: [value: max_() value]

        ::null_boxing_(): of_
            m value
        ;;null_boxing_(of.): null_
            m value = of
    }

    @integer(m value)

    min_(): m
        [Value: 0]

    max_(): m
        [Value: signed[of] max() + 1]

    m(Signed. signed[of]): hm[m]
        [Value: of(.Signed) assert()]

    ::double_or_max(At_least. of): m
        if Value >= max() Value
            @cold_path
            # TODO: do we need a cast here `(M as m?) is_null()`
            if is_null()
                error("Count was null in ::double_or_max, assuming 0")
                [Value. At_least]
            else
                max()
        else
            [Value: max(At_least, Value * 2)]
}

hm_[of_]: hm_[ok_: of_, number_ er_]
