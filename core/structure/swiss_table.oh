# low level data structure that is useful as a foundation for insertion-ordered
# containers that are indexed by an `at`, e.g., insertion-ordered hash maps.
# at a low level, it interleaves a doubly-linked list and a swiss table.
linked_swiss_table_
[    # key for the hash map
     at_
     # element to be held *in* the hash map.  this should include `at`
     # or some way to look up the key `at`.  (see `retrieve_`.)
     element_
     # override if there's another way to get `at` from `element`.
     retrieve_(m;:, element;:): (at;:)
          element at
     bucket_count: count_ = 16
     # type used for counting elements in this table.
     count_: select_count_ = arch_ count_
     # if you really want to optimize the size of this struct, we can use
     # some indirection to put `count` in an allocated spot.
     local_count: bool_ = true
]:
[    @private m:
     [    # we don't use local_capacity so that we can pack these structs better.
          elements; raw_allocation_[element_, header_: element_header_]
          # data for the doubly-linked list.  we don't use a normal DLL
          # because we don't grow this like a stack, we index into it
          # via hash truncation.
          links; raw_allocation_[link_, header_: links_header_]
          # for optimal packing, we put all counts here at the end.
          ELEMENTS_capacity;
          LINKS_capacity;
          count[require: local_count];
     ]
]
{    ::count_(): count_
          @if local_count
               m count
          @else
               # TODO: this might be cleaner:
               # `m elements header_() count ?? 0`
               # but we'd have to do something like `vector3?;`, `vector3 x` being nullish,
               # and the corresponding stuff for `hm_` as well.
               m elements header_() map_({$ok count}, {$_er, 0})

     @private
     element_header_:
     [    count[require: !local_count];
     ]

     @private
     link_:
     [    metadata; vector_[bucket_count, metadatum_]
          linked_offsets; buffer_[bucket_count, linked_offset_]
     ]

     @private
     linked_offset_:
     [    # possibly a partial hash if `count_ < arch_ count_`.
          hash; count_ unsigned_
          offset; count_ offset_
          next; count_ offset_
          previous; count_ offset_
     ]

     # TODO: options in `[]` to put these in the table locally or not.
     @private
     links_header_:
     [    start; count_ offset_
          end; count_ offset_
          # index into `linked_offsets` that is the first free in the list.
          # essentially will a list of the tombstoned elements.
          first_free; count_ offset_
     ]

     capacity_: count_

     @private
     raw_allocation_[of_, header_]: allocation_
     [    of_
          count_
          local_capacity: false
          header_
     ]
}

@private
metadatum_: u8_
[    ;;renew_(): null_
          u8 = 0

     ::empty_(): bool_
          u8 == 0
     ::full_(): bool_
          u8 & 128
     ::tombstoned_(): bool_
          u8 == 127
     # TODO: `matches_(hash)`

     ;;clear_(): null_
          u8 = 0
     ;;fill_(hash. u64_): [remaining_hash: u64_]
          u8 = 128 | (hash & 127)
          remaining_hash: hash >> 7
     ;;tombstone_(): null_
          u8 = 127
]
