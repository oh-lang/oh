# low level data structure that is useful as a foundation for insertion-ordered
# containers that are indexed by an `at`, e.g., insertion-ordered hash maps.
# at a low level, it combines a doubly-linked list and a swiss table.
#linked_swiss_table
[    # key for the hash map
     #at:
     # what's stored in a element at `at` in the table.
     # can be null if we're a `#set`.
     #of:
     slots_per_bucket: #count = 16
     # type used for the capacity (e.g., max number) of elements in this table.
     # NOTE: this is also used for slot capacity, which reduces the
     # number of elements that we can hold via `expected_load_factor`.
     # TODO: consider using a different capacity for slots.  this would
     # probably be most useful if we allowed bit-counts like `#u10`.
     # alternatively we just use `#offset` for slots, which is about 2x the `#count` max.
     #capacity: #select_count = arch #count
     # if you really want to optimize the size of this struct, we can use
     # some indirection to put `count` in an allocated spot if `on_heap`.
     # usage: `#linked_swiss_table[#count_site on_heap, ...]`
     count_site: ~ local
     # these also optimize the size of the struct (if `on_heap`).
     dll_offsets_site: ~ local
     # maximum number of attempts to place a new element.
     # if more than this, will trigger growing the table (rehash).
     max_attempts: #count = 2 * slots_per_bucket
     expected_load_factor: #dbl = 0.87
]:
{    @private
     m elements;
     m groups;
     m count[require: count_site is_local()];

     @public
     ::count(): #count
          @if count_site is_local()
               m count
          @else
               # TODO: this might be cleaner:
               # `m elements header() count ?? 0`
               # but we'd have to do something like `vector3?;`, `vector3 x` being nullish,
               # and the corresponding stuff for `#hm` as well.
               m elements header() map({$ok count}, {$_er, 0})

     ::capacity(): #capacity
          # we'll approximate that we can fit about half as many elements
          # in the table as we have slots.
          m groups capacity() * (group_size // 2)

     #[#
     reserves capacity for the exact number of elements that we expect in this
     hash table.  if the capacity for the elements allocation is already greater
     than the requested capacity, we'll defrag the table (see `;;defrag`).  if
     the requested capacity is larger than the current capacity, we'll increase
     the size of the table and perform a rehash.
     prefer `;;capacity(at_least.)` if the table is expected to grow over time.
     #]#
     ;;capacity(capacity.): #hm[#null]
          m elements capacity(capacity)
          # TODO: we need a name for this operation where you divide
          # into something but make sure you over-supply if necessary.
          old_groups_capacity: m groups capacity()
          m groups capacity((capacity + group_size // 2 - 1) // (group_size // 2))
          if old_groups_capacity != m groups capacity()
               m rehash()

     # reserves capacity for `>= at_least` elements that in this hash table.
     ;;capacity(at_least. #capacity): #hm[#null]
          m elements capacity(at_least)
          old_groups_capacity: m groups capacity()
          m groups capacity(at_least // (group_size // 2))
          if old_groups_capacity != m groups capacity()
               m rehash()

     # returns an error if there's already an element inside the table
     # with the given `at`.  can also return an error if we are out of memory,
     # but will try to expand the table if possible.
     # see also `replace`.
     ;;append(at., of[require: #of].): #hm[#null]
     {    what m locate(at)
               _located_here.
                    #er at_already_present
               ~ no_location_available
                    m grow()
                    retry
               could_be_located_here.
                    m append(could_be_located_here, at, of[require: #of])
     }

     @private
     ;;append(could_be_located_here., at., of[require: #of].): #hm[#null]
     {    (group;) = m groups[could_be_located_here group_offset]
          debug assert(group metadata(could_be_located_here redirect_offset)) & ~ present == 0
          element_offset: m elements append([at, of[require: #of]])
          group redirect(could_be_located_here redirect_offset, element_offset)
     }

     # swaps the `of` that was at `at`, or an error if there wasn't
     # already an element inside the table with the given `at`.
     # see also `append` and `remove`.
     ;;swap[require: #of](at:, of;): #hm[#null]
          what m locate(at)
               located_here.
                    of <-> m elements[located_here element_offset] of
               else
                    #er no_such_at

     # returns an error if there's not already an element inside the table
     # with the given `at`, otherwise the element's `of`.
     ;;remove(at:): #hm[#of]
          what m locate(at)
               located_here.
                    of. m elements remove(located_here element_offset)
                    (group;) = m groups[located here group_offset]
                    group metadata(located_here redirect_offset, ~ tombstone)
                    of
               else
                    #er no_such_at

     # returns the number of elements deleted, should be 0 or 1.
     ;;delete(at:): #count
          what m locate(at)
               located_here.
                    m elements delete(located_here element_offset)
                    (group;) = m groups[located here group_offset]
                    group metadata(located_here redirect_offset, ~ tombstone)
                    1
               else
                    0

     # if readonly, returns an error if there's not already an element inside
     # the table with the given `at`.  if writable, returns an error if `at` is
     # not in the table and either we ran out of memory or `#of` is not defaultable.
     ;:[require: #of](at.): #hm[(of;:)]

     # NOTE TO SELF: we can't do `;;[...]: (of?;)` because we'll potentially
     # swallow errors (e.g., `map[3] = null` should be fine from a memory standpoint,
     # but `map[3] = 7` may throw due to running out of memory.
     ::[require: #of](at.): (of?:)

     ;:each[require: #of](do(at:, of;:): #loop[~#t]:)?: #t
          m elements each$(do($element at, $element of))

     ::each[require: #of == #null](do(at:): #loop[~#t]:)?: #t
          m elements each(do)

     @private
     ::locate(at:): #one_of
     [    # `at` is present in the table
          located_here:
          # `at` is not present in the table, but should go here if you want to add it.
          # it's an empty or tombstoned location.
          could_be_located_here:
          no_location_available: #null
     ]
     {    full_hash: fast_hash(at)
          # best empty/tombstone spot for `at`, if we don't find it in the table:
          best_location; #return = ~ no_location_available
          [at_metadatum: #metadatum, remaining_hash:] = #metadatum extract(full_hash)

          group_count: m groups capacity()
          group_offset; remaining_hash %% group_count

          min(group_count, max_group_probe_count) each _attempt: #count
          {    (group:) = m groups(group_offset)
               # TODO: this part can be sped up with SIMD, if available.
               group_size each redirect_offset:
                    slot_metadatum: group metadata(redirect_offset)
                    if slot_metadatum & ~ present
                         if slot_metadatum != at_metadatum
                              continue
                         element_offset: group redirects[redirect_offset]
                         if likely(at == m elements[element_offset] at)
                              return #located_here
                              [    group_offset
                                   element_offset
                                   redirect_offset
                              ]
                    else
                         if best_location == ~ no_location_available
                              best_location = #could_be_located_here
                              [    group_offset
                                   redirect_offset
                              ]
                         if slot_metadatum == ~ empty
                              return best_location
               group_offset = (group_offset + 1) %% group_count
          }
          best_location
     }

     # shuffles the iteration order of this table.
     # essentially performs a defrag on the new order as well.
     ;;shuffle(): #null

     # optimizes this table so that all elements are laid out in order
     # and the linked list goes from left to right contiguously.
     # this is not really necessary to do unless elements have been deleted,
     # or the table has been shuffled/sorted.
     ;;defrag(): #null

     @private
     # TODO: `dll count_site` should be `managed_elsewhere` if
     # `this count_site` is local.
     #elements: #dll[#element, dll_offsets_site]
     @private
     #element: [at:, of[require: #of];]
     # we want to totally distinguish `#group_offset` and `#element_offset`
     # to avoid using one for the other accidentally.
     @private
     #element_offset: @distinct #count #offset

     @private
     #group_offset: @distinct #count #offset
     @private
     #groups: #allocation[#group]
     @private
     #group:
     [    metadata; #vector[2, #u64]
          redirects; #buffer[group_size, #element_offset]
     ]

     @private
     #located_here:
     [    group_offset:
          element_offset:
          redirect_offset: #u8
     ]

     @private
     #could_be_located_here:
     [    group_offset:
          redirect_offset: #u8
     ]

     #count: #capacity

     #count_site: #memory #site
     #dll_offsets_site: #memory #site
}

@private
#metadatum: #u8
{    ;;renew(): #null
          m u8 = 0

     extract(full_hash. #u64): [metadatum:, remaining_hash:]
          m;
          remaining_hash: m fill(full_hash)
          [m, remaining_hash]

     ::cleared(): #bool
          m u8 == 0
     ::filled(): #bool
          m u8 & present
     ::tombstoned(): #bool
          m u8 == tombstone

     ;;clear(): #null
          m u8 = 0
     ;;fill(full_hash. #u64): [remaining_hash: #u64]
          m u8 = present | (full_hash & 127)
          remaining_hash: full_hash >> 7
     ;;tombstone(): #null
          m u8 = tombstone

     present: #u8 = 128
     tombstone: #u8 = 127
}
