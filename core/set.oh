set_{of_: hashable_, capacity_: select_count_ = arch_ count_}: all_of_
{    hazable{of_};
     countable{count_};
     insertable{of_};
     removable{of_};
}
{    # returns `true` iff `of` is in the set.
     ::has_(of:): bool_

     # inserts `of` into the set.
     ;;insert_(of.): null_

     # returns `true` iff `of` was not already in the set.
     ;;insert_(of.): bool_
          if m has_(of)
               false
          else
               m insert_(of)
               true

     ::count_(): count_

     # unions this set with values from an iterator, returning true if
     # all the values from the iterator were already in this set, otherwise false.
     # can error if running out of memory.
     ;;all_(iterator{of_}.): hm_{bool_}

     # can convert to an iterator.
     ::iterator_(): iterator_{(of:)}

     # removes the last element added to the set if this set is
     # insertion ordered, otherwise any convenient element.
     # returns null if there is no element available.
     ;;remove_()?: of_

     # returns 1 iff the element was in the set, otherwise 0,
     # removing it if present.
     ;;remove_(of:): count_

     count_: capacity_
}

er_: one_of_
{    out_of_memory
     # etc...
}
hm_{of_:}: hm_{ok_: of_, er_}

