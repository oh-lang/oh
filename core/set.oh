set_{of_: hashable_, count_: select_count_ = arch_ count_}: all_of_
{    hazable{of_};
     countable{count_};
}
{    # returns `true` iff `of` is in the set.
     ::has_(of:): bool_

     # inserts `of` into the set.
     ;;insert_(of.): null_

     # returns `true` iff `of` was not already in the set.
     ;;insert_(of.): bool_

     ::count_(): count_

     # unions this set with values from an iterator, returning true if
     # all the values from the iterator were already in this set, otherwise false.
     # can error if running out of memory.
     ;;all_(iterator{of_}.): hm_{bool_}

     # can convert to an iterator.
     ::iterator_(): iterator_{(of:)}

     # removes the last element added to the set if this set is
     # insertion ordered, otherwise any convenient element.
     # returns an error if there is no element available.
     ;;remove_(): hm_{of_}

     # returns true iff the element was in the set.
     # will remove it if so.
     ;;remove_(of:): hm_{of_}
}

er_: one_of_
{    out_of_memory
     # etc...
}
hm_{of_:}: hm_{ok_: of_, er_}

