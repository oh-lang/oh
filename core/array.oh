#array[#of:, #capacity: #select_count = arch #count]: #all_of
[    #indexable[#of, #count];
     # we could make this `#hashable` if `#of` is hashable, but we'll
     # implicitly make it hashable (by defining a `::hash` method)
     # and only add to hashable's lookup table as needed.
]
{    # index can be negative to support "from the back" logic.
     # NOTE: this can be null in case `#capacity` does not support negative indexing.
     #index: #count #index
     # always positive.
     #offset: #count #offset

     # sets this array's capacity to exactly `max(m count(), capacity, min_capacity)`;
     # i.e., no elements would get deleted by this operation, and there may be a minimum
     # capacity that will always be respected, e.g., for a local array.
     # prefer `array capacity(at_least. count)` because it will grow the array
     # in an amortized way if you are increasing the capacity over time.
     ;;capacity(capacity.): #hm[#null]

     :;[in_bounds.]: #(of:;)

     ;;append(of.): #hm[#null]
          m capacity(at_least: m count() + 1) assert()
          m append(of, assuming. capacity)

     #assuming: #one_of[enough_capacity:]
     # called as `array append(3, #assuming enough_capacity)`
     ;;append(of., assuming.): #null

     ::count(): #count

     ;;count[require: #of is #defaultable](NEW_count.): #hm[#null]
          OLD_count: m count()
          if NEW_count == OLD_count
               return #ok()
          elif NEW_count > OLD_count
               m capacity(at_least: NEW_count) assert()
               while m count() < NEW_count
                    m append(#of(), #assuming enough_capacity)
          else
               while m count() > NEW_count
                    UNUSED_of: m pop()

     ::capacity(): #count

     ;;capacity(at_least. #count): #hm[#null]
          current_capacity: m capacity()
          if current_capacity >= at_least
               return #ok()
          doubled_capacity: min(2 * current_capacity, #count max)
          m capacity(max(at_least, doubled_capacity))

     #keeping: #one_of[same_capacity:, no_capacity:]
     # call as `array clear(#keeping no_capacity)` to deallocate
     # or `array clear(#keeping same_capacity)` to keep the allocation.
     ;;clear(keeping.): #null
          while m count() > 0
               UNUSED_of: m pop()
          what keeping
               ~# same_capacity
                    pass
               ~# no_capacity
                    m capacity(0)

     ::[index.]?: #(of:)
          # TODO: use m[in_bounds]

     ;;[index.]: #hm[#(of;)]
          # TODO: use m[in_bounds]

     ;;pop()?: #of
          if m count() > 0
               of. m pop()
               of
          else
               null

     ;;pop(): #of

     # returns a value of the array element at the specified index,
     # or the end of the array if not specified.  returns null if the element
     # would be out of bounds (e.g., `select >= m count()`).
     ;;pop(select. #select[#index, #offset])?: #of
          # don't resize the array in case `index >= m count`.
          what m in_bounds(select)
               ok.
                    m pop(ok)
               IGNORE_er.
                    null

     ;;pop(in_bounds.): #of
          debug assert(in_bounds < m count())
          result: m[in_bounds]!
          m erase(in_bounds)
          result

     # returns the number of elements erased
     ;;erase(select. #select[#index, #offset]): #count
          if m in_bounds(select) is ok.
               m erase(ok)
          else
               0

     ;;erase(in_bounds.): #count
          debug assert(in_bounds < m count())
          range(in_bounds, m count() - 1) each DESTINATION_in_bounds:
               m[DESTINATION_in_bounds] = m[in_bounds: DESTINATION_in_bounds + 1]!
          _of: m pop()
          1

     # returns a copy of this array, but sorted.
     ::sort[require: #of is #orderable](): #o

     # sorts this array in place.
     ;;sort[require: #of is #orderable](): #null

     #[#
     sorts with a custom comparator that acts on a single element at a time.
     `fn(by: #of): ~#t` should be easy to calculate on the fly, otherwise
     you should run `tabulated`.  the result type `#t` should be easily
     comparable via `<`, `<=`, etc.  examples:
          ```
          array: ["abc", "de", "f", "ghij"]
          print(array sort((by:): by count()))    # prints ["f", "de", "abc", "ghij"]
          print(array sort$($by count()))         # same, but via lambda arguments
          ```
     #]#
     :;sort_{require: t_ is orderable_}
     (    fn_(by: of_): ~t_
     ):        respectively_{o_, null_}

     #[#
     sorts using a tabulated work array (with an additional cost of
     `O(m count_() * memory_(t_))`).  should be used in case `fn_(by)`
     is expensive to compute.  example:
          ```
          array: ["abc", "de", "f", "ghij"]
          # should print ["f", "de", "abc", "ghij"]:
          print_(array sort_({$tabulated_by count_()}))
          ```
     #]#
     :;sort_{require: t_ is orderable_}
     (    fn_(tabulated_by: of_): ~t_
     ):        respectively_{o_, null_}

     # sorts with a custom comparator that acts on two elements at a time.
     # without certain transitive properties, the result's order may not make sense.
     :;sort_(fn_(left: of_, right: of_): ordering_): respectively_{o_, null_}

     ::hash_{require: of_ is hashable_}(~builder;): null_
          m each of:
               builder hash_(of)

     maybe_local_{local_bytes_}:
               maybe_local_array_{of_, local_bytes_, locality_: count_}
     non_local_: non_local_array_{of_, count_}

     @alias heap_: non_local_
     @alias heap_or_local_: maybe_local_

     er_: CONTAINER_er_
     count_: capacity_
}

# for simplicity, rounds to multiples of 8 bytes.
local_bytes_: select_{16, 24, 32, 40, 48, 56, 64}

[hm_, CONTAINER_er_]: \/container
