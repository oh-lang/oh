array[of, capacity: count]: all_of
[   hashable
    indexable_sequence[of]
]
{   maybe_local[Local_bytes, locality: hoisted_primitive = h16]:
            maybe_local_array[Local_bytes, locality, of]
    non_local[capacity: hoisted_primitive = h64]: non_local_array[capacity, of]

    @alias heap: non_local
    @alias heap_or_local: maybe_local

    ::capacity(): m count

    ;;capacity(Capacity.): null 

    ::count(): m count
        M Count

    ;;count[Require: of is defaultable](NEW_count): hm[count]
        OLD_count: M Count
        if NEW_count == OLD_count
            return ok(OLD_count)
        if NEW_count > OLD_count
            M capacity(At_least: Count) assert()
            while M Count < NEW_count
                append(of())
        else
            assert(NEW_count >= 0, er Invalid_count)
            while M Count > NEW_count
                UNUSED_of: M pop()
        ok(OLD_count)

    clear: one_of[Keeping_capacity, Dropping_capacity]
    {   @alias Keep_capacity: Keeping_capacity
        @alias Drop_capacity: Dropping_capacity
    }

    ;;clear(Clear: clear = Keeping_capacity): null
        while M Count > 0
            UNUSED_of: M pop()
        what One_of
            Keeping_capacity
                pass
            Dropping_capacity
                M capacity(0)

    ;;append(Of.): hm[null]
   
    :;[In_bounds.]: (Of:;)

    # moves out and resets the value at this index.
    ;;[Index.]!?: of
        what M in_bounds(Index)
            Ok.
                M[Ok]!
            IGNORE_er.
                Null

    ;;[In_bounds.]!: of

    ;;pop()?: of
        # TODO: can implement here in terms of moot
    
    # returns a value of the array element at the specified index,
    # or the end of the array if not specified.  returns null if the element
    # would be out of bounds (e.g., `Index >= M count()`).
    ;;pop(Index.)?: of
        # don't resize the array in case `Index >= M Count`.
        what M in_bounds(Index)
            Ok.
                M pop(Ok)
            IGNORE_er.
                Null
        # alternatively: `M in_bounds(Index) map({M pop($Ok)}, {$_er, Null})`

    ;;pop(In_bounds.): of
        debug assert(In_bounds >= 0 and In_bounds < M count())
        Result: M[In_bounds]!
        M erase(In_bounds)
        Result

    ;;erase(Index.): m count
        if M in_bounds(Index) is Ok.
            M erase(Ok)
        else
            0

    ;;erase(In_bounds.): m count
        debug assert(In_bounds >= 0 and In_bounds < M count())
        range(In_bounds, M count() - 1) each Destination_index:
            M[Destination_index] = M[In_bounds: Destination_index + 1]!
        M pop()
        1

    !!(M): bool
        count(M) > 0

    # returns a copy of this array, but sorted.
    # only makes sense if `of` is orderable.
    ::sort[Require: of is orderable](): you

    # sorts this array in place.
    # only makes sense if `of` is orderable.
    ;;sort[Require: of is orderable](): null

    # returns a sorted copy with a custom comparator that acts on a single element at a time.
    # `fn(By)` should be easy to calculate on the fly, otherwise you should run with `Tabulate`.
    # the result type `t` should be easily comparable via `<`, `<=`, etc.
    # examples:
    #   Array sort((By): By count())    # results in ["f", "de", "abc", "ghij"]
    #   Array::sort($By count())        # same, but without the lambda $
    ::sort[Require: t is orderable](fn(By: of): ~t): you

    # sorts in place with a custom comparator that acts on a single element at a time.
    # `fn(By)` should be easy to calculate on the fly, otherwise you should run with `Tabulate`.
    # the result type `t` should be easily comparable via `<`, `<=`, etc.
    # examples:
    #   Array; ["abc", "de", "f", "ghij"]
    #   Array sort($By count())         # `Array` becomes ["f", "de", "abc", "ghij"]
    #   Array;;sort((By): By count())   # same, but without the lambda $
    ;;sort[Require: t is orderable](fn(By: of): ~t): null

    # sorts using a tabulated work array (additional `O(N * size_of(t))` memory cost).
    # should be called in the case `fn(By)` is expensive to compute.
    :;sort[Require: t is orderable]
    (   fn(By: of): ~t, Tabulated. one_of[Tabulated]
    ):  respectively[you, null]

    # sorts with a custom comparator that acts on two elements at a time.
    # without certain transitive properties, the result's order may not make sense.
    :;sort(fn(Left: of, Right: of): comparison): respectively[you, null]

    ::hash(~Builder;):
    {   Builder hash(of)  # make array hashes distinct based on type.
        M each (Index., Of:)
            Builder hash(Index)
            Builder hash(Of)
    }

    ;;capacity(At_least: m count): hm[null]
        Current_capacity: M capacity()
        if At_least <= Current_capacity 
            return ok()
        M capacity(Current_capacity double_or_max(At_least. 4))
}

[allocation, hm, er]: \/allocation
