array_[of_, count_with_: select_count_]: all_of_
[   hashable_
    indexable_sequence_[of_]
]
{   maybe_local_[local_bytes_]:
            maybe_local_array_[of_, local_bytes_, locality_: count_with_]
    non_local_: non_local_array_[of_, count_with_]

    @alias heap_: non_local_
    @alias heap_or_local_: maybe_local_

    ::capacity_(): count_with_

    # prefer `array capacity_(at_least. count_with)` because it will grow the array
    # in an amortized way if you are increasing the capacity over time.
    ;;capacity_(count_with.): hm_[null_]

    ::count_(): count_with_

    # called as `array append_(3, assuming. capacity)`
    ;;append_(of., assuming. one_of_[capacity]): null_

    ;;pop_()?: of_

    ;;capacity_(at_least. count_with): hm_[null_]
        # TODO: can implement here

    ;;append_(of.): hm_[null_]
        # TODO: can implement here

    ;;count_[require: of_ is defaultable_](NEW_count_with.): hm_[null_]
        OLD_count: m count_()
        if NEW_count == OLD_count
            return ok_(OLD_count)
        if NEW_count > OLD_count
            capacity_(at_least_: NEW_count) assert()
            while m count_() < NEW_count
                append_(of_())
        else
            assert_(NEW_count >= 0, er invalid_count)
            while m count_() > NEW_count
                UNUSED_of: m pop_()

    # call as `array clear_(keeping. no_capacity)` to deallocate
    # or `array clear_(keeping. same_capacity)` to keep the allocation.
    ;;clear_(keeping. one_of_[no_capacity, same_capacity]): null_
        while m count > 0
            UNUSED_of: m pop()
        what keeping
            same_capacity
                pass
            no_capacity
                m capacity_(0)

    :;[in_bounds.]: (of:;)

    # moves out and resets the value at this index.
    ;;[index.]!?: of_
        what m in_bounds_(index)
            ok.
                m[ok]!
            IGNORE_er.
                null

    # returns a value of the array element at the specified index,
    # or the end of the array if not specified.  returns null if the element
    # would be out of bounds (e.g., `index >= m count_()`).
    ;;pop_(index.)?: of_
        # don't resize the array in case `index >= m count`.
        what m in_bounds_(index)
            ok.
                m pop_(ok)
            IGNORE_er.
                Null
        # alternatively: `m in_bounds_(index) map_({m pop_($ok)}, {$_er, null})`

    ;;pop_(in_bounds.): of_
        debug assert(In_bounds >= 0 and In_bounds < M count())
        Result: M[In_bounds]!
        M erase(In_bounds)
        Result

    ;;erase(Index.): m count
        if M in_bounds(Index) is Ok.
            M erase(Ok)
        else
            0

    ;;erase(In_bounds.): m count
        debug assert(In_bounds >= 0 and In_bounds < M count())
        range(In_bounds, M count() - 1) each Destination_index:
            M[Destination_index] = M[In_bounds: Destination_index + 1]!
        M pop()
        1

    !!(M): bool
        count(M) > 0

    # returns a copy of this array, but sorted.
    # only makes sense if `of` is orderable.
    ::sort[Require: of is orderable](): you

    # sorts this array in place.
    # only makes sense if `of` is orderable.
    ;;sort[Require: of is orderable](): null

    # returns a sorted copy with a custom comparator that acts on a single element at a time.
    # `fn(By)` should be easy to calculate on the fly, otherwise you should run with `Tabulate`.
    # the result type `t` should be easily comparable via `<`, `<=`, etc.
    # examples:
    #   Array sort((By): By count())    # results in ["f", "de", "abc", "ghij"]
    #   Array::sort($By count())        # same, but without the lambda $
    ::sort[Require: t is orderable](fn(By: of): ~t): you

    # sorts in place with a custom comparator that acts on a single element at a time.
    # `fn(By)` should be easy to calculate on the fly, otherwise you should run with `Tabulate`.
    # the result type `t` should be easily comparable via `<`, `<=`, etc.
    # examples:
    #   Array; ["abc", "de", "f", "ghij"]
    #   Array sort($By count())         # `Array` becomes ["f", "de", "abc", "ghij"]
    #   Array;;sort((By): By count())   # same, but without the lambda $
    ;;sort[Require: t is orderable](fn(By: of): ~t): null

    # sorts using a tabulated work array (additional `O(N * size_of(t))` memory cost).
    # should be called in the case `fn(By)` is expensive to compute.
    :;sort[Require: t is orderable]
    (   fn(By: of): ~t, Tabulated. one_of[Tabulated]
    ):  respectively[you, null]

    # sorts with a custom comparator that acts on two elements at a time.
    # without certain transitive properties, the result's order may not make sense.
    :;sort(fn(Left: of, Right: of): comparison): respectively[you, null]

    ::hash(~Builder;):
    {   Builder hash(of)  # make array hashes distinct based on type.
        M each (Index., Of:)
            Builder hash(Index)
            Builder hash(Of)
    }

    ;;capacity(At_least: m count): hm[null]
        Current_capacity: M capacity()
        if At_least <= Current_capacity 
            return ok()
        M capacity(Current_capacity double_or_max(At_least. 4))
}

# for simplicity, rounds to multiples of 8 bytes.
local_bytes_: select_[16, 24, 32, 40, 48, 56, 64]

[allocation, hm, er]: \/allocation
