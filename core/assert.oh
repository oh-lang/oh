# for wrapping any value into an assertion, e.g., `assert(x) == 5`
# in a function that returns a `hm` result.
assert
[    #block_hm: #hm[~#ok:, ~#er:]
     # NOTE: `#assertion` will throw a `#runtime_er`.
     require: #runtime_er in #er
]
(    ~of.
     block[~block_hm_:];
):        #assertion[#of, #er, #held_er: #null}

# for wrapping any value into an assertion, e.g., `assert(x) == 5`
# in a function that can panic.
assert[require: #oh_info caller() can_panic()](~of.)
:         #assertion[#of, #er, #held_er: #null}

# for converting a nullable value into a non-null, e.g., `not_null: assert(x?)`
# in a function that returns a `#hm` result.
assert[#block_hm: #hm[~#ok:, ~#er:], #er: #runtime_er]
(    ~of?.
     block[~#block_hm:];
):        #of

# for converting a nullable value into a non-null, e.g., `not_null: assert_(x?)`
# in a function that can panic.
assert[require: #oh_info caller() can_panic()](~of?.)
:         #of

@private
#assertion[#of:, #RETURNED_er: #runtime_er, #held_er: #RETURNED_er]:
[    of;
     oh_info:
     transformation; #str
     held_er[require: #held_er];
]
{    #g(~t., ~GIVEN_RETURNED_er., oh_info. ~# caller(), transformation. ""):
               #g[#t, #RETURNED_er: #GIVEN_RETURNED_er]
          [t, held_er. GIVEN_RETURNED_er, oh_info, transformation]

     # TODO: something like this for nullable.
     #g(hm[~#ok:, ~#er:]., oh_info. ~# caller(), transformation. ""):
               g[#hm[#ok, #er], #RETURNED_er: #er, #held_er: #null]
          # `held_er` doesn't need to be specified because we'll return
          # the error from `hm` if need be.
          [hm, oh_info, transformation]

     #g(~t., oh_info. ~# caller(), transformation. ""): #g[#t]
          [t, held_er. #runtime_er unspecified, oh_info, transformation]

     ;;descope
     [    require: #RETURNED_ER in #er
          #hm: #hm[~#IGNORE_ok:, ~#er:]
     ]
     (    block[~#hm:];
     ):        #null
          @if #of is #bool
               if !m of
                    block exit(m held_er!)
          @elif #of is #hm
               if m of is er.
                    block exit(er)
          @else
               # TODO

     ;;descope
     [    require: #oh_info caller() can_panic()
     ](): #null
          @if #of is #bool
               if !m of
                    print(er: "${m oh_info}: expected ${m transformation}")
                    panic("expected ${m transformation}")
          @elif #of is #hm
               if m of is er.
                    print(er: "${m oh_info}: expected ${m transformation}, got ${er}")
                    panic("expected ${m transformation} to be OK, got ${er}")
          @else
               if !m transformation
                    print(er: "${m oh_info}: expected an expression like `assert(x) == 7`")

     @methods(#of) @each method:
          if method name == "descope"
               continue
          # `method arguments` will include `m:`, `m;`, or `m.`, so we don't
          # need to add `::`, `;;`, or `..` to the start here.
          @concat(method name)
          (    ...method arguments:, oh_info. #oh_info caller()
          ): #g[method #return]
               # TODO: in release mode, we need to make `transformation` not a string
               # and do something else.
               transformation. "${m transformation} ${method represent(...method arguments)}"
               returning. @concat(method name)(...method arguments)
               # TODO: i think we need to plan for `m` to be descoped here.
               # TODO: maybe this method should be converted to `..` regardless of `m`.
               #g(returning, oh_info, transformation)
}

#runtime_er: #one_of
[    unspecified:
     invalid_argument:
     broken_invariant:
]
{   @alias invalid_arguments: invalid_argument
}
