file_tag_(str:): str_
     swizzle_(encode_(str))

file_untag_(str:): str_
     decode_(swizzle_(str o_()))

#[#
substitute di/trigraphs or inserting them for rare letters.
unicode (and common letters) are passed through as-is.
     ```
     "qu" -> "q"
     "q" -> "\q"
     ".oh" -> "."
     "." -> "\."
     ```
#]#
@test "encode_"
     @test ". should normally be .oh"
          assert_(encode_(".oh")) == "."
          # we could optimize this to be `"\\.|"` but this is correct for now:
          assert_(encode_(".or")) == "\\.or"
          assert_(encode_("en.oh")) == "&."
     @test "qu and q"
          assert_(encode_("quell")) == "qeL"
          assert_(encode_("qwack")) == "\\qwaK"
     @test "brackets and braces"
          assert_(encode_("tion")) == "[]"
          assert_(encode_("code")) == "{}"
@private
encode_(str:): str_
{    result; str_
     iterator[rune_, can: peek]; _(str)
     while iterator next_(str) is rune.
          @if arch_ windows
               if rune == file_path_ separator
                    # this is invalid as a character in a Windows path anyway.
                    rune = '/'
          what rune
               't'
                    what iterator peek_(str)
                         'h'  # "th"
                              iterator next_(str)
                              result += '#'  # # -> th
                         'i'  # "ti"
                              iterator next_(str)
                              result += '['  # [ -> ti
                         'e'  # "te"
                              iterator next_(str)
                              result += ';'  # ; -> te
                         'o'  # "to"
                              iterator next_(str)
                              result += 'Q'  # Q -> to
                         else
                              result += 't'
               'h'
                    if iterator peek_(str) == 'e' # "he"
                         iterator next_(str)
                         result += 'H'  # H -> he
                    else
                         result += 'h'
               'i'
                    what iterator peek_(str)
                         'n'  # "in"
                              iterator next_(str)
                              result += 'I'  # I -> in
                         't'  # "it"
                              iterator next_(str)
                              result += 'K'  # K -> it
                         'e'  # "ie"
                              iterator next_(str)
                              result += '?'  # ? -> ie
                         'r'  # "ir"
                              iterator next_(str)
                              result += '<'  # < -> ir
                         else
                              result += 'i'
               'e'
                    what iterator peek_(str)
                         'e'  # "ee"
                              iterator next_(str)
                              result += 'E'  # E -> ee
                         'r'  # "er"
                              iterator next_(str)
                              result += '>'  # > -> er
                         'n'  # "en"
                              iterator next_(str)
                              result += '&'  # & -> en
                         else
                              result += 'e'
               'a'
                    what iterator peek_(str)
                         'r'  # "ar"
                              iterator next_(str)
                              result += '^'  # ^ -> ar
                         else
                              result += 'a'
               'u'
                    if iterator peek_(str) == 'r'
                         iterator next_(str)
                         result += 'V'  # V -> ur
               'n'
                    what iterator peek_(str)
                         'n'  # "nn"
                              iterator next_(str)
                              result += 'N'
                         else
                              result += 'n'
                    
               'o'
                    what iterator peek_(str)
                         'n'  # "on"
                              iterator next_(str)
                              result += ']'  # ] -> on
                         'r'  # "or"
                              iterator next_(str)
                              result += '|'  # | -> or
                         'u'  # "ou"
                              iterator next_(str)
                              result += 'U'  # U -> ou
                         'o'  # "oo"
                              iterator next_(str)
                              result += 'O'  # O -> oo
                         'w'  # "ow"
                              iterator next_(str)
                              result += '!'  # ! -> ow
                         'a'  # "oa"
                              iterator next_(str)
                              result += '\'' # ' -> oa
                         else
                              result += 'o'
               '.'
                    if iterator peek_(str) == 'o'
                         iterator next_(str)
                         if iterator peek_(str) == 'h'
                              iterator next_(str)
                              result += '.' # . -> .oh
                         else
                              # we had `.o` and then something else...
                              # for the `.` and the `o`:
                              result += "\\.o"
                              # theoretically we could backtrack and see if `o` digraphs
                              # with anything, but for simplicity of iteration we'll do this.
                    else
                         # we had `.` but something else, escape it:
                         result += "\\."
               'q'
                    if iterator peek_(str) == 'u'
                         iterator next_(str)
                         result += 'q'
                    else
                         result += "\\q"
               '`', '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '+', '-', '=',
               '[', ']', '{', '}', '\\', '|', ';', ':', '\'', '"', ',', '<', '>', '?',
               'j', 'x', 'z', # q is another rarely used lowercase letter, but is handled above.
               'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
               'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                    result += '\\'
                    result += rune
     result
}

# swaps every other letter from the start of the string with those from the back.
@test "swizzle_"
     @test "works for small string edge cases"
          assert_(swizzle_("")) == ""
          assert_(swizzle_("q")) == "q"
     @test "for odd-sized strings, alternates swapping first/second letter"
          assert_(swizzle_("xyz")) == "zyx"   # first
          assert_(swizzle_("54321")) == "52341" # second
          assert_(swizzle_("pqrstuv")) == "vqtsrup" # first
          assert_(swizzle_("123456789")) == "183654729" # second
     @test "for even-sized strings, starts swapping on the first letter"
          assert_(swizzle_("mn")) == "nm"
          assert_(swizzle_("abcd")) == "dbca"
          assert_(swizzle_("123456")) == "624351"
          assert_(swizzle_("builders")) == "sueldirb"
@private
swizzle_(str.): str_
{    # there's a way to do this in place, but it feels harder from a maintenance/logic
     # perspective because strings are utf8 encoded (packed).
     array[rune_]; str interator_[rune_]()
     RUNE_count: array count_()
     if RUNE_count <= 1
          # return early so that we can assume `RUNE_count > 1`.
          return str
     EXCLUSIVE_HALFWAY_index: RUNE_count // 2
     index; if RUNE_count %% 2 == 0
          # even-sized string, start swapping on first letter
          index_(0)
     else
          # odd-sized string
          index_(1) - EXCLUSIVE_HALFWAY_index %% 2
     MAX_index: RUNE_count - 1
     while index < EXCLUSIVE_HALFWAY_index
          array swap_(index, MAX_index - index)
          index += 2
     array iterator_()
}
