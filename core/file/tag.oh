#[#
     ```
     file_tag_("abc/def.oh")

     ```
#]#
file_tag_: str_
{    m_(str:): m_
          encode. _(str)
          # next step: reverse the position of every other rune with one at the end of the array.
          swizzle_(encode)

     ::to_(): str_
}

#[#
substitute di/trigraphs or inserting them for rare letters.
unicode (and common letters) are passed through as-is.
     ```
     "qu" -> "q"
     "q" -> "\q"
     ".oh" -> "."
     "." -> "\."
     ```
#]#
encode_(str:): str_
{    result; str_
     iterator[rune_, can: peek]; _(str)
     while iterator next_(str) is rune.
          @if arch_ windows
               if rune == file_path_ separator
                    # this is invalid as a character in a Windows path anyway.
                    rune = '/'
          what rune
               't'
                    what iterator peek_(str)
                         'h'
                              iterator next_(str)
                              result += 'P'
                         'i'
                              iterator next_(str)
                              result += 'j'
                         'e'
                              iterator next_(str)
                              result += 'T'
                         'o'
                              iterator next_(str)
                              result += 'Q'
                         else
                              result += 't'
               'h'
                    if iterator peek_(str) == 'e'
                         iterator next_(str)
                         result += 'H'
                    else
                         result += 'h'
               'i'
                    what iterator peek_(str)
                         'n'
                              iterator next_(str)
                              result += 'P'
                         't'
                         'r'
                         else
                              result += 'i'
               '.'
                    if iterator peek_(str) == 'o'
                         iterator next_(str)
                         if iterator peek_(str) == 'h'
                              iterator next_(str)
                              result += '.' # stands for ".oh"
                         else
                              # we had `.o` and then something else...
                              # for the `.` and the `o`:
                              result += "\\.o"
                              # theoretically we could backtrack and see if `o` digraphs
                              # with anything, but for simplicity of iteration we'll do this.
                    else
                         # we had `.` but something else, escape it:
                         result += "\\."
               'q'
                    if iterator peek_(str) == 'u'
                         iterator next_(str)
                         result += 'q'
                    else
                         result += "\\q"
               'j',
               'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
               'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                    result += '\\'
                    result += rune
     result
}

# swaps every other letter from the start of the string with those from the back.
@test "swizzle_"
     @test "works for small string edge cases"
          assert_(swizzle_("")) == ""
          assert_(swizzle_("q")) == "q"
     @test "for odd-sized strings, alternates swapping first/second letter"
          assert_(swizzle_("xyz")) == "zyx"   # first
          assert_(swizzle_("54321")) == "52341" # second
          assert_(swizzle_("pqrstuv")) == "vqtsrup" # first
          assert_(swizzle_("123456789")) == "183654729" # second
     @test "for even-sized strings, starts swapping on the first letter"
          assert_(swizzle_("mn")) == "nm"
          assert_(swizzle_("abcd")) == "dbca"
          assert_(swizzle_("123456")) == "624351"
          assert_(swizzle_("builders")) == "sueldirb"
swizzle_(str.): str_
{    # there's a way to do this in place, but it feels harder from a maintenance/logic
     # perspective because strings are utf8 encoded (packed).
     array[rune_]; str interator_[rune_]()
     RUNE_count: array count_()
     if RUNE_count <= 1
          # return early so that we can assume `RUNE_count > 1`.
          return str
     EXCLUSIVE_HALFWAY_index: RUNE_count // 2
     index; if RUNE_count %% 2 == 0
          # even-sized string, start swapping on first letter
          index_(0)
     else
          # odd-sized string
          index_(1) - EXCLUSIVE_HALFWAY_index %% 2
     MAX_index: RUNE_count - 1
     while index < EXCLUSIVE_HALFWAY_index
          array swap_(index, MAX_index - index)
          index += 2
     array iterator_()
}
