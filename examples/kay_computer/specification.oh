#[#
the kay computer is named for 1000 being a "k" amount of something,
and the word size for this computer can contain 1000 possibilities.
we call a single word a "kay" when we don't specify the data it contains.

because `1000 == 26^2 + 18^2`, we can represent a word in executable
code using either two alphabetic letters in sequence (e.g., Az), in
particular capitalizing the first so we know it's the start of a word,
or by choosing two from the following 18 pairs (first, second), again
making first/second digits distinguishable to make sure we know where
the start of a word is (e.g., 4& or @-).  this is the ASCII version
of an executable; we discuss later a preferred binary version.

```
     pairs: array_{pair_{u8_}} =
     [    ['/', '{']
          ['0', '|']
          ['1', '}']
          ['2', '~']
          ['3', '!']
          ['4', '"']
          ['5', '#']
          ['6', '$']
          ['7', '%']
          ['8', '&']
          ['9', '\'']
          [':', '(']
          [';', ')']
          ['<', '*']
          ['=', '+']
          ['>', ',']
          ['?', '-']
          ['@', '.']
     ]
     # which can be calculated as
     # `pairs[eighteen] = [first_(eighteen), second_(eighteen)]` via:
     eighteen_: one_of_{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}
     first_(eighteen.): u8_
          47 + digit
     second_(eighteen.): u8_
          if eighteen < 4
               123 + eighteen
          else
               29 + eighteen
```

ASCII executable code can be commented via `[this is a comment]`.
all other characters, including newlines and spaces, are ignored.
we reserve the right to "truncate" words, e.g., A3 would be
short word A followed by a short word 3, whereas Ab3% would
be a normal word Ab followed by a normal word 3%.
however, for the time being, short words are errors.

binary executable code uses 2 bytes to represent a kay; a kay is
slightly less than 10 bits, so 16 bits is sufficient.  we could pack
more kays into several bytes, but we take a conservative approach and
use an lexicographic code with `N = 16` bits, minimum `D = 4` bits of
distance between code points, e.g., using an algorithm adapted from
https://en.wikipedia.org/wiki/Lexicographic_code#Implementation; this
would normally give 2048 code points, but we include the code points
352 and 8483 and require every additional code point's individual bytes
to not have a 0 byte or a byte from '\n' to '#'.  these inefficiencies
reduce the number of code points to 1001.  to reduce to 1000 valid code
points, we make 8483, which is "#!" in little endian, a special command
for the file reader.  it instructs the file reader to skip subsequent
bytes until a '\n' byte is found.  this enables a line that indicates
how to run the binary, e.g., "#!/usr/bin/kay" at the start of a file.
the first 20 code points are (putting 352 into its sorted position):
```
261, 302, 313, 331, 342, 352, 386, 412, 439, 465
493, 506, 515, 548, 570, 584, 597, 623, 653, 656
```
because this code has a Hamming distance of 4, we can correct 1 bit
errors and detect up to 3 bit errors when reading code.

just because the kay count is 1000 doesn't mean we can't represent
larger numbers; the basic kilo types have 10^3 = 1000 possibilities, but
there are also mega types (2 words, up to 10^6 = 1_000_000 possibilities),
giga types (3 words, up to 10^9 = 1_000_000_000 possibilities),
tera types (4 words, up to 10^12 = 1_000_000_000_000 possibilities),
peta types (5 words, up to 10^15 possibilities)
exa types (6 words, up to 10^18 possibilities),
zetta types (7 words, up to 10^21 possibilities),
yotta types (8 words, up to 10^24 possibilities),
ronna types (9 words, up to 10^27 possibilities),
quetta types (10 words, up to 10^30 possibilities), and many more types
that are built out of types like this.  kay computers specify
the endianness of primitive types as little endian.

positive numbers can be represented by unsigned types, e.g.,
`u_kilo_` represent numbers from 0 to 999, `u_mega_` from 0 to 999_999, etc.
instead of needing to remember the metric prefix, you can also postfix
the number of words like `u1_` for `u_kilo_` and `u2_` for `u_mega_`, etc.

pessimistic types can represent positive and negative numbers,
and are called pessimistic because they skew towards negative numbers,
e.g, `p_kilo_` represents numbers from 0 to 499, then -500 to -1.
this is like two's complement in standard binary computers.

optimistic types are similar but skew towards positive numbers.
e.g., `o_kilo_` represents numbers from 0 to 500, then -499 to -1.

symmetric types represent equal counts of positive and negative
numbers, with an additional NaN value.  e.g., `s_kilo_` represents
numbers from 0 to 499, then a NaN value, then -499 to -1.
we break with IEEE754 and `x == NaN` will be true if `x` is NaN.

big integer representations are not required to follow this exact
specification, but the reference kay computer will use an array
of `o_kilo_` values for "digits" of the integer in base 1000.

the kay computer has a few dedicated fixed-point types,
`f_kilo_` which represents -4.97 to 4.97 with precision 0.01,
`f_mega_` which represents +-499.997 with precision 0.001,
`f_giga_` which represents +-49,999.9997 with precision 0.0001,
`f_tera_` which represents +-4,999,999.99997 with precision 0.00001,
or `fx_` representing approximately `+-0.05 * 10^(2 * x)` with precision
`10^-(x + 1)` for for word count `x`.
each type has 5 "invalid" values: NaN (0/0), positive and negative
infinities (+-∞), and positive and negative infinitesimals (+-1/∞).
we break with IEEE754 and `x == NaN` will be true if `x` is NaN.

TODO: floating-point types

the kay computer strives to make adding classes/types easy.

where possible, the kay computer tries to avoid adding type data
to class variables, i.e., when those variables are strongly typed.

```
     # `u_kilo_` is a word, `p_mega_` is two words,
     # so `data_` is exactly three words if its type is known.
     data_: [u: u_kilo_, p: p_mega_]
```

you can create a stack of any type, including `any_` type.  if
the type has ambiguities (e.g., `any_` can be any type), there is
a type ID that gets appended before the instance data.  stacks
have `O(1)` pop/append but because `any_` type data can be sized
differently, looking up the `k`th element is `O(min_(k, n - k))`.

executable code looks like a list of operations (op-codes) followed
by a certain number of arguments (specified by the operation).

```
     0-100     # push a `s_kilo_` number to the stack, i.e., 0 through 100, no argument
     101-200   # push a `s_kilo_` number to the stack, -100 through -1, no argument
               # convert to a type, type given as an argument
               # TOS increment ++
               #    `[ 1 ++ ] -> [ 2 ]`
               #    TODO: should this work?  or should `++` just be `1 +=`
               #    for array types, appends a default value
               #    `[ [1 2] ++ ] -> [ [1 2 0] ]`
               # TOS decrement --
               #    for array types, pops the last element
               # `+=` pop the TOS and add it to what was the NOS (now TOS)
               #    `[ 1 5 += ] -> [ 6 ]`
               #    for array types on the NOS, appends the TOS to it
               #    `[ [1 2] 3 += ] -> [ [1 2 3] ]`
               #    for arrays on TOS and NOS, appends all elements
               #    `[ [1 2] [3 4] += ] -> [ [1 2 3 4] ]`
               # `-=` pop the TOS and subtract it from what was on the NOS (now TOS)
               #    `[ 1 5 -= ] -> [ -4 ]`
               #    for array types on the NOS, will remove the last value that matches.
               #    `[ [1 2 3 4] 3 -= ] -> [ [1 2 4] ]`
               #    `[ [5 6] 6 -= ] -> [ [5] ]`
               #    `[ [0 0 0] 0 -= ] -> [ [0 0] ]`
               # `+` pops the TOS and NOS, and pushes their addition
               #    the difference from `+=` is that the variable from NOS is not updated
               #    in case it is a reference to something else.
               # `-` pops the TOS and NOS, and pushes their subtraction
               #    the difference from `-=` is that the variable from NOS is not updated
               #    in case it is a reference to something else.
               # divide
               # modify the next opcode by popping the TOS, interpreting it as a stack,
               #    running the next operation with that stack
               #    then pushing the stack back onto the stack.
```

#]#
